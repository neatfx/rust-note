<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>利用 Deref 特质进行常规引用操作 | Rust 学习笔记</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.8bcf7c97.css" as="style"><link rel="preload" href="/assets/js/app.7819f68a.js" as="script"><link rel="preload" href="/assets/js/2.c7e95d31.js" as="script"><link rel="preload" href="/assets/js/49.22c5f8ae.js" as="script"><link rel="prefetch" href="/assets/js/10.71b7f3db.js"><link rel="prefetch" href="/assets/js/11.33bb0966.js"><link rel="prefetch" href="/assets/js/12.f7bdb846.js"><link rel="prefetch" href="/assets/js/13.14713a71.js"><link rel="prefetch" href="/assets/js/14.7a72f426.js"><link rel="prefetch" href="/assets/js/15.79443f0e.js"><link rel="prefetch" href="/assets/js/16.bfb56dec.js"><link rel="prefetch" href="/assets/js/17.c67e5630.js"><link rel="prefetch" href="/assets/js/18.28df6e14.js"><link rel="prefetch" href="/assets/js/19.6dba0f6e.js"><link rel="prefetch" href="/assets/js/20.7fe96ebb.js"><link rel="prefetch" href="/assets/js/21.c1ca2b28.js"><link rel="prefetch" href="/assets/js/22.8d30fb36.js"><link rel="prefetch" href="/assets/js/23.a04d06e6.js"><link rel="prefetch" href="/assets/js/24.8f9dbc43.js"><link rel="prefetch" href="/assets/js/25.1ab69d7f.js"><link rel="prefetch" href="/assets/js/26.9892c271.js"><link rel="prefetch" href="/assets/js/27.e2eb50d5.js"><link rel="prefetch" href="/assets/js/28.31270cab.js"><link rel="prefetch" href="/assets/js/29.e5fde72d.js"><link rel="prefetch" href="/assets/js/3.065ccf56.js"><link rel="prefetch" href="/assets/js/30.80a32322.js"><link rel="prefetch" href="/assets/js/31.827d06ec.js"><link rel="prefetch" href="/assets/js/32.b74942dc.js"><link rel="prefetch" href="/assets/js/33.db15a8db.js"><link rel="prefetch" href="/assets/js/34.343562c8.js"><link rel="prefetch" href="/assets/js/35.c33e3c9f.js"><link rel="prefetch" href="/assets/js/36.61e40180.js"><link rel="prefetch" href="/assets/js/37.907cc52e.js"><link rel="prefetch" href="/assets/js/38.87af5dd2.js"><link rel="prefetch" href="/assets/js/39.4ee57d9f.js"><link rel="prefetch" href="/assets/js/4.4b7d39e7.js"><link rel="prefetch" href="/assets/js/40.8d7408e4.js"><link rel="prefetch" href="/assets/js/41.c2046a9f.js"><link rel="prefetch" href="/assets/js/42.6cc376da.js"><link rel="prefetch" href="/assets/js/43.63a455c5.js"><link rel="prefetch" href="/assets/js/44.0d15d778.js"><link rel="prefetch" href="/assets/js/45.9be4bc9f.js"><link rel="prefetch" href="/assets/js/46.e22e8db9.js"><link rel="prefetch" href="/assets/js/47.dbd72152.js"><link rel="prefetch" href="/assets/js/48.ec6ca506.js"><link rel="prefetch" href="/assets/js/5.3befbe85.js"><link rel="prefetch" href="/assets/js/50.4a58f660.js"><link rel="prefetch" href="/assets/js/51.36d42e96.js"><link rel="prefetch" href="/assets/js/52.2ec659fc.js"><link rel="prefetch" href="/assets/js/53.541947fb.js"><link rel="prefetch" href="/assets/js/54.1cf56973.js"><link rel="prefetch" href="/assets/js/55.27ed2009.js"><link rel="prefetch" href="/assets/js/56.4011a578.js"><link rel="prefetch" href="/assets/js/57.70babd7b.js"><link rel="prefetch" href="/assets/js/58.39568e0b.js"><link rel="prefetch" href="/assets/js/59.98811df6.js"><link rel="prefetch" href="/assets/js/6.fa4dd12d.js"><link rel="prefetch" href="/assets/js/60.c0a0c3f8.js"><link rel="prefetch" href="/assets/js/61.83913c6f.js"><link rel="prefetch" href="/assets/js/62.0ea87c47.js"><link rel="prefetch" href="/assets/js/7.e902d7c9.js"><link rel="prefetch" href="/assets/js/8.ac97398c.js"><link rel="prefetch" href="/assets/js/9.52c69a98.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8bcf7c97.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-navbar"><!----> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/" class="sidebar-link">Rust Note</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>项目管理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>通用编程概念</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/variable.html" class="sidebar-link">变量与可变性</a></li><li><a href="/data-type.html" class="sidebar-link">数据类型</a></li><li><a href="/struct.html" class="sidebar-link">结构体</a></li><li><a href="/enumeration.html" class="sidebar-link">枚举</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/collections/" class="sidebar-heading clickable"><span>集合</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/smart-pointer/" class="sidebar-heading clickable router-link-active open"><span>智能指针</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/smart-pointer/box.html" class="sidebar-link">使用 Box&lt;T&gt; 在堆上存储数据</a></li><li><a href="/smart-pointer/deref-trait.html" class="active sidebar-link">利用 Deref 特质进行常规引用操作</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/smart-pointer/deref-trait.html#解引用" class="sidebar-link">解引用</a></li><li class="sidebar-sub-header"><a href="/smart-pointer/deref-trait.html#解引用强制多态" class="sidebar-link">解引用强制多态</a></li></ul></li><li><a href="/smart-pointer/drop-trait.html" class="sidebar-link">利用 Drop 特质进行清理</a></li><li><a href="/smart-pointer/rc.html" class="sidebar-link">引用计数智能指针 Rc&lt;T&gt;</a></li><li><a href="/smart-pointer/refcell.html" class="sidebar-link">@ 内部可变性模式</a></li><li><a href="/smart-pointer/reference-cycles-and-memory-leak.html" class="sidebar-link">@ 引用循环与内存泄漏</a></li></ul></section></li><li><a href="/function.html" class="sidebar-link">函数</a></li><li><a href="/control-flow.html" class="sidebar-link">流程控制</a></li><li><a href="/error-handling.html" class="sidebar-link">错误处理</a></li><li><a href="/comment.html" class="sidebar-link">注释</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>所有权</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>抽象</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>生命周期</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>并发编程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>测试</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>模式匹配</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程范式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>高级特性</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="利用-deref-特质进行常规引用操作"><a href="#利用-deref-特质进行常规引用操作" class="header-anchor">#</a> 利用 <code>Deref</code> 特质进行常规引用操作</h1> <h2 id="解引用"><a href="#解引用" class="header-anchor">#</a> 解引用</h2> <p>解引用运算符 <code>*</code>（ dereference operator ）</p> <p>通过解引用运算符可以追踪以下指针类型的值：</p> <ul><li>常规引用</li> <li>内置智能指针</li> <li>自定义智能指针（ 通过实现 <code>Deref</code> 特质重载解引用运算符，从而可当作常规引用进行操作 ）</li></ul> <h3 id="常规引用"><a href="#常规引用" class="header-anchor">#</a> 常规引用</h3> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span> <span class="token comment">// 引用</span>

    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 编译错误: can't compare `{integer}` with `&amp;{integer}`</span>
    <span class="token comment">// assert_eq!(5, y);</span>

    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解引用</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="智能指针"><a href="#智能指针" class="header-anchor">#</a> 智能指针</h3> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> Box<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h3 id="自定义智能指针"><a href="#自定义智能指针" class="header-anchor">#</a> 自定义智能指针</h3> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span>Deref<span class="token punctuation">;</span>

<span class="token keyword">struct</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">MyBox</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// impl&lt;T&gt; Deref for MyBox&lt;T&gt; {</span>
<span class="token comment">//     type Target = T; // 定义关联类型</span>

<span class="token comment">//     fn deref(&amp;self) -&gt; &amp;T {</span>
<span class="token comment">//         &amp;self.0 // 返回希望通过 * 运算符访问的值的引用</span>
<span class="token comment">//     }</span>
<span class="token comment">// }</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> y <span class="token operator">=</span> MyBox<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 编译错误: type `MyBox&lt;{integer}&gt;` cannot be dereferenced</span>
    <span class="token function">assert_eq!</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>没有 <code>Deref</code> 特质的情况下，编译器只会解引用 <code>&amp;</code> 引用类型。因此 Rust 无法对 <code>MyBox&lt;T&gt;</code> （ 非引用类型 ）进行解引用，导致编译时错误。</p> <p>任何实现了 <code>Deref</code> 特质的类型，编译器通过 <code>deref</code> 方法可以获取：</p> <ul><li>类型的值</li> <li>一个内部数据的 <code>&amp;</code> 引用（ 类型知道如何将其解引用 ）</li></ul> <p>在 Rust 内部， 解引用操作 <code>*y</code> 将被转换为 <code>*(y.deref())</code> ( 调用 <code>deref</code> 方法后直接引用 ）</p> <h4 id="代码修正"><a href="#代码修正" class="header-anchor">#</a> 代码修正</h4> <p>将实现 <code>Deref</code> 特质部分的代码取消注释即可通过编译</p> <h4 id="所有权规范"><a href="#所有权规范" class="header-anchor">#</a> 所有权规范</h4> <ul><li><code>deref</code> 方法的返回结果为值的引用（ 如果直接返回值，值的所有权将被移出 <code>self</code> ）</li> <li>底层转换 <code>*(y.deref())</code> 采用普通解引用的形式</li></ul> <p>这是因为，多数情况下，使用解引用运算符的时候不需要获取 <code>MyBox&lt;T&gt;</code> 内部值的所有权</p> <h2 id="解引用强制多态"><a href="#解引用强制多态" class="header-anchor">#</a> 解引用强制多态</h2> <h3 id="函数或方法传参时的隐式解引用强制多态"><a href="#函数或方法传参时的隐式解引用强制多态" class="header-anchor">#</a> 函数或方法传参时的隐式解引用强制多态</h3> <p>将实现了 <code>Deref</code> 的类型的引用转换为原始类型通过 <code>Deref</code> 所能够转换的类型的引用</p> <p>传递与形参类型不同的特定类型实参（ 实现了 <code>Deref</code> 的类型的引用 ）时，解引用强制多态自动发生，通过一系列 <code>deref</code> 方法调用，实参类型被转换成形参类型。这种隐式转换无需过多的显式引用和解引用，也使得编写同时作用于引用或智能指针的代码更容易。</p> <div class="language-rust line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">use</span> std<span class="token punctuation">::</span>ops<span class="token punctuation">::</span>Deref<span class="token punctuation">;</span>

<span class="token keyword">struct</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">fn</span> <span class="token function">new</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">MyBox</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">impl</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> Deref <span class="token keyword">for</span> MyBox<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">type</span> Target <span class="token operator">=</span> T<span class="token punctuation">;</span>

    <span class="token keyword">fn</span> <span class="token function">deref</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-&gt;</span> <span class="token operator">&amp;</span>T <span class="token punctuation">{</span>
        <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">hello</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">println!</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, {}!&quot;</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">fn</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> m <span class="token operator">=</span> MyBox<span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>String<span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">&quot;Rust&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">hello</span><span class="token punctuation">(</span><span class="token string">&quot;Rust&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 字符串 slice 作为参数</span>
    <span class="token function">hello</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">*</span>m<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果没有解引用强制多态支持，需编写晦涩的转换代码</span>
    <span class="token function">hello</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 解引用强制多态，直接使用 MyBox&lt;String&gt; 类型值的引用作为参数</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h4 id="缺少解引用强制多态支持的情况"><a href="#缺少解引用强制多态支持的情况" class="header-anchor">#</a> 缺少解引用强制多态支持的情况</h4> <p><code>(*m)</code> 将 <code>MyBox&lt;String&gt;</code> 解引用为 String。接着 <code>&amp;</code> 和 <code>[..]</code> 获取了整个 String 的字符串 slice 来匹配 hello 的签名，所有这些符号混在一起难以读写和理解。</p> <h4 id="解引用强制多态的处理过程"><a href="#解引用强制多态的处理过程" class="header-anchor">#</a> 解引用强制多态的处理过程</h4> <p><code>MyBox&lt;T&gt;</code> 实现了 <code>Deref</code> 特质，Rust 通过调用 <code>deref</code> 将 <code>&amp;MyBox&lt;String&gt;</code> 转换为 <code>&amp;String</code>，标准库中提供了 <code>String</code> 上的 <code>Deref</code> 实现（ 返回字符串 slice ），Rust 再次调用 <code>deref</code> 将 <code>&amp;String</code> 变为 <code>&amp;str</code>，从而符合 <code>hello</code> 函数的定义。</p> <h4 id="性能提示"><a href="#性能提示" class="header-anchor">#</a> 性能提示</h4> <p>当类型实现了 <code>Deref</code> 特质，Rust 会分析这些类型并使用任意多次 <code>Deref::deref</code> 调用以获得匹配参数的类型。这些解析都发生在编译时，所以解引用强制多态没有运行时性能损失。</p> <h3 id="解引用强制多态如何与可变性交互"><a href="#解引用强制多态如何与可变性交互" class="header-anchor">#</a> 解引用强制多态如何与可变性交互</h3> <ul><li>重载不可变引用的 <code>*</code> 运算符 ---&gt; 实现 <code>Deref</code> 特质</li> <li>重载可变引用的 <code>*</code> 运算符 ---&gt; 实现 <code>DerefMut</code> 特质</li></ul> <p>Rust 在发现以下三种情况时会进行解引用强制多态：</p> <ul><li>当 <code>T: Deref&lt;Target=U&gt;</code> 时，从 <code>&amp;T</code> 到 <code>&amp;U</code></li> <li>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时，从 <code>&amp;mut T</code> 到 <code>&amp;mut U</code></li> <li>当 <code>T: Deref&lt;Target=U&gt;</code> 时，从 <code>&amp;mut T</code> 到 <code>&amp;U</code></li></ul> <p>前两种情况除了可变性之外是相同的：</p> <h4 id="第一种情况"><a href="#第一种情况" class="header-anchor">#</a> 第一种情况</h4> <p>如果有一个 <code>&amp;T</code>，而 <code>T</code> 实现了返回 <code>U</code> 类型的 <code>Deref</code>，则可以直接得到 <code>&amp;U</code></p> <h4 id="第二种情况"><a href="#第二种情况" class="header-anchor">#</a> 第二种情况</h4> <p>对于可变引用有着与不可变引用相同的行为</p> <h4 id="第三种情况"><a href="#第三种情况" class="header-anchor">#</a> 第三种情况</h4> <blockquote><p>如果有一个可变引用，其必须是这些数据的唯一引用，否则程序将无法编译</p></blockquote> <p>根据上述借用规则，可变引用能够转换为不可变引用（ 永远不会违背借用规则 ），反之是不可能的。
将不可变引用转换为可变引用需要数据只能有一个不可变引用，而借用规则无法保证这一点。
因此，Rust 无法假设将不可变引用转换为可变引用是可能的。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/smart-pointer/box.html" class="prev">使用 Box&lt;T&gt; 在堆上存储数据</a></span> <span class="next"><a href="/smart-pointer/drop-trait.html">利用 Drop 特质进行清理</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.7819f68a.js" defer></script><script src="/assets/js/2.c7e95d31.js" defer></script><script src="/assets/js/49.22c5f8ae.js" defer></script>
  </body>
</html>
