(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{221:function(v,_,e){"use strict";e.r(_);var c=e(0),t=Object(c.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"基于特质的可扩展并发"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于特质的可扩展并发"}},[v._v("#")]),v._v(" 基于特质的可扩展并发")]),v._v(" "),e("p",[v._v("Rust 本身提供的并发相关的内容很少，之前讨论的几乎所有内容都来自标准库。这同时意味着并发方案不受标准库或语言限制，可以自己编写并发功能或者使用别人编写的并发功能。")]),v._v(" "),e("p",[v._v("标准库 "),e("code",[v._v("std::marker")]),v._v(" 中的 "),e("code",[v._v("Sync")]),v._v(" 和 "),e("code",[v._v("Send")]),v._v(" 特质是两个内嵌于 Rust 语言中的并发概念。")]),v._v(" "),e("p",[v._v("它们允许 Rust 的并发保证能被扩展到用户定义或者标准库中提供的类型中。")]),v._v(" "),e("h2",{attrs:{id:"send-允许在线程间转移所有权"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#send-允许在线程间转移所有权"}},[v._v("#")]),v._v(" "),e("code",[v._v("Send")]),v._v(" 允许在线程间转移所有权")]),v._v(" "),e("p",[e("code",[v._v("Send")]),v._v(" 标记特质表明类型的所有权可以在线程间传递。")]),v._v(" "),e("p",[v._v("任何完全由 "),e("code",[v._v("Send")]),v._v(" 的类型组成的类型会被自动标记为 "),e("code",[v._v("Send")]),v._v("，除了裸指针（ raw pointer ），几乎所有基本类型都是 "),e("code",[v._v("Send")]),v._v(" 的。不过有一些例外，比如 "),e("code",[v._v("Rc<T>")]),v._v(" 类型。")]),v._v(" "),e("p",[v._v("智能指针 "),e("code",[v._v("Rc<T>")]),v._v(" 不是 "),e("code",[v._v("Send")]),v._v(" 的，因为如果克隆了 "),e("code",[v._v("Rc<T>")]),v._v(" 的值并尝试将克隆的所有权转移到另一个线程，两个线程都可能同时更新引用计数（ 这将引发错误 ），拥有线程安全的引用计数而付出性能代价。为此，"),e("code",[v._v("Rc<T>")]),v._v(" 被实现为用于单线程场景。")]),v._v(" "),e("p",[v._v("Rust 类型系统和 "),e("code",[v._v("trait bound")]),v._v(" 会禁止在线程间发送未标记为 "),e("code",[v._v("Send")]),v._v(" 的类型。")]),v._v(" "),e("p",[v._v("当尝试在线程间发送 "),e("code",[v._v("Rc<T>")]),v._v(" 的时候，会得到错误：")]),v._v(" "),e("div",{staticClass:"language-shell line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-shell"}},[e("code",[v._v("the trait Send is not implemented "),e("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("for")]),v._v(" Rc"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("Mutex"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v("<")]),v._v("i3"),e("span",{pre:!0,attrs:{class:"token operator"}},[e("span",{pre:!0,attrs:{class:"token file-descriptor important"}},[v._v("2")]),v._v(">>")]),v._v("`。\n")])]),v._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[v._v("1")]),e("br")])]),e("p",[v._v("而换用标记为 "),e("code",[v._v("Send")]),v._v(" 的 "),e("code",[v._v("Arc<T>")]),v._v(" 时，代码可通过编译。")]),v._v(" "),e("h2",{attrs:{id:"sync-允许多线程访问"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sync-允许多线程访问"}},[v._v("#")]),v._v(" "),e("code",[v._v("Sync")]),v._v(" 允许多线程访问")]),v._v(" "),e("p",[e("code",[v._v("Sync")]),v._v(" 标记特质表明类型可以安全的在多个线程中拥有其值的引用。即对于任意类型 "),e("code",[v._v("T")]),v._v("，如果 "),e("code",[v._v("&T")]),v._v(" 是 "),e("code",[v._v("Send")]),v._v(" 的话 "),e("code",[v._v("T")]),v._v(" 就是 "),e("code",[v._v("Sync")]),v._v(" 的。这意味着其引用就可以安全的发送到另一个线程。")]),v._v(" "),e("p",[v._v("与 "),e("code",[v._v("Send")]),v._v(" 类似，Rust 中的基本类型是 "),e("code",[v._v("Sync")]),v._v(" 的，完全由 "),e("code",[v._v("Sync")]),v._v(" 的类型组成的类型也是 "),e("code",[v._v("Sync")]),v._v(" 的。")]),v._v(" "),e("p",[v._v("智能指针 "),e("code",[v._v("Rc<T>")]),v._v(" 也不是 "),e("code",[v._v("Sync")]),v._v(" 的，这与其不是 "),e("code",[v._v("Send")]),v._v(" 的原因相同。")]),v._v(" "),e("p",[e("code",[v._v("RefCell<T>")]),v._v(" 和 "),e("code",[v._v("Cell<T>")]),v._v(" 类型不是 "),e("code",[v._v("Sync")]),v._v(" 的。"),e("code",[v._v("RefCell<T>")]),v._v(" 在运行时的借用检查不是线程安全的。")]),v._v(" "),e("p",[e("code",[v._v("Mutex<T>")]),v._v(" 是 "),e("code",[v._v("Sync")]),v._v(" 的，可被用于在多线程中共享访问。")]),v._v(" "),e("h2",{attrs:{id:"手动实现-send-和-sync-是不安全的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#手动实现-send-和-sync-是不安全的"}},[v._v("#")]),v._v(" 手动实现 "),e("code",[v._v("Send")]),v._v(" 和 "),e("code",[v._v("Sync")]),v._v(" 是不安全的")]),v._v(" "),e("p",[v._v("通常不需要手动实现 "),e("code",[v._v("Send")]),v._v(" 和 "),e("code",[v._v("Sync")]),v._v(" 特质，因为由 "),e("code",[v._v("Send")]),v._v(" 和 "),e("code",[v._v("Sync")]),v._v(" 组成的类型，会自动被标记为是 "),e("code",[v._v("Send")]),v._v(" 和 "),e("code",[v._v("Sync")]),v._v(" 的。并且标记特质无需实现任何方法，它们只是用来加强并发相关的不可变性的。手动实现这些标记特质涉及"),e("strong",[v._v("编写不安全的 Rust 代码")]),v._v("。")]),v._v(" "),e("p",[v._v("当前重点是，在创建由不是 "),e("code",[v._v("Send")]),v._v(" 和 "),e("code",[v._v("Sync")]),v._v(" 的部分构成的并发类型时，需要多加注意确保并发安全。")])])}),[],!1,null,null,null);_.default=t.exports}}]);