(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{222:function(t,v,_){"use strict";_.r(v);var e=_(0),s=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"并发编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#并发编程"}},[t._v("#")]),t._v(" 并发编程")]),t._v(" "),_("p",[t._v("使并发编程变得安全且高效是 Rust 的设计目标之一。")]),t._v(" "),_("p",[t._v("Rust 通过所有权和类型检查在编译时检测并发错误，拒绝编译有问题（ 数据竞争、无效引用等 ）的代码并提供参考信息，避免将难以跟踪的并发BUG推迟到运行时解决。一旦代码编译通过，就应当坚信它们能够正确运行于多线程环境，不会出现其他语言中常见的并发 BUG，可以放心对代码进行重构。")]),t._v(" "),_("p",[t._v("Rust 自带处理并发的内容很少，适用多线程场景的并发方案多由 Crate 实现，且比标准库发展的更快。")]),t._v(" "),_("p",[t._v("很多语言提供的并发处理方案都很有特色。例如，Erlang 提供了优雅的消息传递并发功能，但只有模糊不清的在线程间共享状态的方法。对于高级语言来说，牺牲底层控制提供抽象便利是其价值所在，因此只实现部分解决方案是合理的策略。然而，对于底层语言，则希望在任何给定情况下有最好的性能以及更少的硬件抽象。因此，Rust 提供了多种工具，贴近实际情况和需求处理并发。")]),t._v(" "),_("p",[t._v("本章节内容：")]),t._v(" "),_("ul",[_("li",[t._v("创建线程同时运行多段代码")]),t._v(" "),_("li",[t._v("消息传递并发（ 通道被用来在线程间传递消息 ）")]),t._v(" "),_("li",[t._v("共享状态并发（ 多个线程可以访问同一片数据 ）")]),t._v(" "),_("li",[_("code",[t._v("Sync")]),t._v(" 和 "),_("code",[t._v("Send")]),t._v(" 特质（ 将 Rust 的并发保证扩展到用户自定义或标准库提供的类型中 ）")])])])}),[],!1,null,null,null);v.default=s.exports}}]);