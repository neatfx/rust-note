# 使用线程同步运行代码

## 进程 vs 线程

在大部分现代操作系统中，程序运行于进程中，操作系统负责管理多个进程。在程序内部，也可以拥有多个同时运行的独立部分，运行这些独立部分的功能被称为线程。

将程序中的计算拆分进多个线程可以改善性能，不过也会增加复杂性。因为线程是同时运行的，所以无法保证不同线程中的代码执行顺序，而这可能引发问题：

- 竞争状态（ Race conditions ），多个线程以不一致的顺序访问数据或资源
- 死锁（ Deadlocks ），两个线程相互等待对方停止使用其所拥有的资源
- 只发生在特定条件下且难以稳定重现和修复的 BUG

## 线程模型

### 线程模型分类

- 由语言调用操作系统 API 创建线程的模型被称为 1:1 模型（ 一个 OS 线程对应一个语言线程 ）
- 由语言提供实现的线程被称为绿色线程，也被称为 M:N 模型（ 语言会在 N 个 OS 线程的上下文中执行 M 个线程 ）

### 线程模型 @ Rust

每一种线程模型都有其优势和取舍，对于 Rust 来说最重要的取舍是运行时支持。

- Rust 需要做到几乎没有运行时（ 更小的二进制输出，易于在更多上下文中与其他语言相结合，比如调用 C 语言 ）
- M:N 模型需要更大的语言运行时来管理线程

#### 选择线程模型

- Rust 标准库只提供了 1:1 线程模型的实现
- 由于Rust 是足够底层的语言，如果愿意牺牲性能来换取更好的线程运行控制和更低的上下文切换开销，可以使用实现了 M:N 模型的 Crate

## 使用 `spawn` 创建新线程

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // 传递闭包
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

由于标准库使用 1:1 模型（ 依赖于操作系统如何调度线程 ），因此该示例：

- 不能保证新建线程会被执行（ 因为无法保证线程运行顺序 ）
- 主线程结束时，新建线程也会提前结束（ 部分执行 ）
- 无法保证新建线程先于主线程输出

### 使用 `join` 等待所有线程结束

修复新建线程部分执行或者完全不执行的问题：

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // thread::spawn 的返回值类型是 JoinHandle（ 一个拥有所有权的值 ）
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    // 阻塞当前线程（ 主线程 ）直到 handle 代表的线程（ 新建线程 ）结束
    // 确保新建线程在 main 退出前全部执行
    handle.join().unwrap();
}
```

考虑移动 `handle.join()` 的位置：

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

主线程会等待直到新建线程执行完毕之后才开始执行 `for` 循环，所以输出不会交替出现：

```shell
hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
```

## 使用 `move` 闭包跨线程访问数据

尝试在新建线程中使用主线程中创建的数据：

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

得到错误：

```shell
error[E0373]: closure may outlive the current function, but it borrows `v`,
which is owned by the current function
 --> src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {:?}", v);
  |                                           - `v` is borrowed here
  |
help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
```

Rust 会推断引用 `v` 的生命周期，因为 `println!` 需要 `v`，闭包会尝试借用 `v`。然而 Rust 不知道新建线程会执行多久，所以无法确认 `v` 的引用是否一直有效。

例如，下面代码中 `v` 的引用就不再有效：

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        // 使用闭包的线程，尝试使用一个在主线程中被回收的引用 v
        println!("Here's a vector: {:?}", v);
    });

    drop(v); // v 不再有效，此时还有线程在使用该引用的数据，产生了悬垂引用！

    handle.join().unwrap();
}
```

在闭包之前增加 `move` 关键字，强制闭包获取其使用的值的所有权，而不是由 Rust 推断使用借用值。

修正后的代码可以通过编译：

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

使用 `move` 后，主线程中将不能对 `v` 调用 `drop` 方法：

```shell
error[E0382]: use of moved value: `v`
  --> src/main.rs:10:10
   |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec<i32>`, which does
   not implement the `Copy` trait
```

关键字 `move` 覆盖了 Rust 默认保守的借用规定，使线程可以获取其他线程中数据的所有权，从而得以安全执行。引用仍然需要遵守所有权规则，不允许在被移动的数据所在线程中继续操作该数据。
