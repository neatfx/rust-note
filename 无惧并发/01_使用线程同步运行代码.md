# 使用线程同步运行代码

## 进程 vs 线程

在大部分现代操作系统中，程序代码运行于进程中，操作系统同时管理多个进程。在程序内部，也可以拥有多个同步运行的独立部分，运行这些独立部分的功能被称为线程。

因为程序同时运行多个任务，所以将程序中的计算拆分到多个线程可以改善性能，不过也增加了复杂性。因为线程可以同步运行，所以无法保证不同线程中程序代码的运行次序，而这可能引发问题：

- 竞争状态（ Race conditions ），多个线程以不一致的顺序访问数据或资源
- 死锁（ Deadlocks ），两个线程相互等待对方停止使用其所拥有的资源，导致两个线程均无法继续运行
- 只发生在特定条件下出现且难以重现和准确修复的 BUG

Rust 尝试减轻使用线程的负面影响，但是在多线程环境下编程仍然需要谨慎思考并且要求具有与单线程运行的程序不同的代码结构。

## 线程模型

编程语言以不同的方式实现线程。许多操作系统都提供了创建新线程的 API。

### 线程模型种类

- 由语言调用操作系统 API 创建线程的模型被称为 1:1 模型（ 一个语言线程对应一个 OS 线程 ）
- 由语言本身提供实现的线程被称为*绿色线程*，使用绿色线程的语言将会在不同数目的操作系统线程上下文中执行线程。因此，绿色线程模型也被称为 M:N 模型（ M 个绿色线程对应 N 个 OS 线程，M 和 N 不必相等 ）

### 如何在 Rust 中选择线程模型

每一种线程模型都有其优势和取舍，对于 Rust 来说最重要的取舍是运行时支持。*运行时* 是一个模糊的术语，在不同的上下文环境中具有不同的含义。

在这里，我们所说的运行时是指每个二进制中经由语言所包含的代码。代码可大可小，这取决于语言本身，但是所有非嵌入式语言都有同样数量的运行时代码。因此，当人们说某种语言“无运行时”，他们通常是指“小型运行时”。小型运行时功能少但是具有较小的二进制输出体积优势，使得它很容易在更多上下文中将语言与其他语言结合。尽管许多语言不太在乎增加运行时的大小以换取更多功能，但是 Rust 需要做到几乎没有运行时的同时保持调用 C 语言维持性能的能力。

- M:N 模型需要更大的语言运行时来管理线程，因此，Rust 标准库只提供了 1:1 线程模型的实现
- 由于 Rust 是足够底层的语言，如果愿意牺牲性能来换取更好的线程运行控制和更低的上下文切换开销，可以使用实现了 M:N 模型的 Crate

## 使用 `spawn` 创建新线程

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // 传递闭包
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

由于标准库使用 1:1 模型（ 依赖于操作系统如何调度线程 ），因此该示例：

- 不能保证新建线程会被执行（ 因为无法保证线程运行顺序 ）
- 主线程结束时，新建线程也会提前结束（ 部分执行 ）
- 无法保证新建线程先于主线程输出

### 使用 `join` 等待所有线程结束

修复新建线程部分执行或者完全不执行的问题：

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // thread::spawn 的返回值类型是 JoinHandle（ 一个拥有所有权的值 ）
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    // 阻塞当前线程（ 主线程 ）直到 handle 代表的线程（ 新建线程 ）结束
    // 确保新建线程在 main 退出前全部执行
    handle.join().unwrap();
}
```

考虑移动 `handle.join()` 的位置：

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
}
```

主线程会等待直到新建线程执行完毕之后才开始执行 `for` 循环，所以输出不会交替出现：

```shell
hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
```

## 使用 `move` 闭包跨线程访问数据

尝试在新建线程中使用主线程中创建的数据：

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

得到错误：

```shell
error[E0373]: closure may outlive the current function, but it borrows `v`,
which is owned by the current function
 --> src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!("Here's a vector: {:?}", v);
  |                                           - `v` is borrowed here
  |
help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
```

Rust 会推断引用 `v` 的生命周期，因为 `println!` 需要 `v`，闭包会尝试借用 `v`。然而 Rust 不知道新建线程会执行多久，所以无法确认 `v` 的引用是否一直有效。

例如，下面代码中 `v` 的引用就不再有效：

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        // 使用闭包的线程，尝试使用一个在主线程中被回收的引用 v
        println!("Here's a vector: {:?}", v);
    });

    drop(v); // v 不再有效，此时还有线程在使用该引用的数据，产生了悬垂引用！

    handle.join().unwrap();
}
```

在闭包之前增加 `move` 关键字，强制闭包获取其使用的值的所有权，而不是由 Rust 推断使用借用值。

修正后的代码可以通过编译：

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

使用 `move` 后，主线程中将不能对 `v` 调用 `drop` 方法：

```shell
error[E0382]: use of moved value: `v`
  --> src/main.rs:10:10
   |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec<i32>`, which does
   not implement the `Copy` trait
```

关键字 `move` 覆盖了 Rust 默认保守的借用规定，使线程可以获取其他线程中数据的所有权，从而得以安全执行。引用仍然需要遵守所有权规则，不允许在被移动的数据所在线程中继续操作该数据。
