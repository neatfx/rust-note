# 无惧并发

安全高效地处理并发编程是 Rust 语言的另一个重要目标。自从更多的计算机开始利用它们的多个处理器，*并发编程*（ 程序的不同部分独立执行 ）和 *并行编程*（ 程序的不同部分同时执行 ）变得愈加重要。长期以来，针对多个处理器进行编程是一件非常困难的事情且很容易出错，Rust 希望改变这种状况。

起初，Rust 团队认为确保内存安全与防范并发问题是两个需要使用不同方法来解决的不相关的挑战。随着时间推移，团队发现所有权和类型系统是帮助管理内存安全以及并发问题的一个强大工具组合！得益于所有权和类型检查，许多并发错误在 Rust 中都是编译时错误而不是运行时错误。因而，相较于让你花费大量时间尝试对一个运行时发生的并发 BUG 进行复现，在 Rust 中，不正确的代码（ 包含数据竞争、无效引用等 ）将会被拒绝编译并呈现错误信息对问题进行说明。因此，你可以在开发时对代码进行修复，而不是等到代码有可能已经被部署到生产环境之后再进行修复。我们将 Rust 的这一面称之为 “无惧并发”。无惧并发使得在不引入新 BUG 的情况下编写极少出错且易于重构的代码成为可能。

<!-- 一旦代码编译通过，就应当坚信它们能够正确运行于多线程环境，不会出现其他语言中常见的并发 BUG，可以放心对代码进行重构。 -->

<!-- Rust 自带处理并发的内容很少，适用多线程场景的并发方案多由 Crate 实现，且比标准库发展的更快。 -->

很多语言都坚守其固有的并发问题处理方案。例如，Erlang 提供了优雅的消息传递并发功能，却只有晦涩难懂的线程间共享状态处理方式。对于高级语言来说，牺牲一些底层控制提供抽象便利是其价值所在，只支持部分可能的解决方案是合理的策略。然而，对于底层语言来说，则被期望在任何给定情况下具有最佳性能以及更少的硬件抽象。因而，Rust 为处理并发问题提供了各种贴近实际情况和需求的建模工具。

本章节涉及内容：

- 如何创建线程用于同时运行多段代码
- 消息传递并发（ 使用通道在线程间传递消息 ）
- 共享状态并发（ 多个线程共同访问某块数据 ）
- `Sync` 和 `Send` 特质（ 将 Rust 的并发保证扩展到用户自定义类型以及标准库提供的类型中 ）
