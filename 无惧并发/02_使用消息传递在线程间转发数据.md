# 使用消息传递在线程间转发数据

## 通道

由标准库提供的通道是 Rust 实现消息传递并发的重要工具。可将编程中的通道想象成流水的通道，比如河流。如果将橡皮鸭或者船放进水流中，它将顺流而下到达河道终点。

编程中的通道有两个部分：发送者和接受者。代码中的某些部分使用想要发送的数据来调用发送者上的方法，其他部分从接收端检查到达的消息。两者共同组成通道，当发送者或者接受者任一被丢弃时，我们称之为通道被关闭。

这里，我们将实现的程序包含一个线程，该线程产生值并且将值发送到通道中，另一个线程将接受值并打印出来。我们将发送简单值来描述通道的功能。一旦熟悉了该技术，你可以使用通道来实现一个聊天系统，或者一个计算系统，拥有许多计算线程进行计算并把各自部分发送到一个用于聚合结果的线程。

首先，创建一个通道但是不使用它进行任何处理。以下代码不会通过编译，因为 Rust 不清楚我们想要通过通道发送的值的类型：

```rust
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
}
```

`std::sync::mpsc::channel` 函数用于创建新通道，`mpsc` 是 `multiple producer, single consumer`（ 多个生产者，单个消费者 ）的缩写。Rust 标准库实现通道的方式表明一个通道可以有多个产生值的发送端，但只能有一个消费这些值的接收端。

`std::sync::mpsc::channel` 函数返回一个元组：元组的第一个元素是发送端，第二个元素是接收端。通常使用 `tx` 和 `rx` 作为发送者（ `transmitter` ）和 接收者（ `receiver` ）的缩写形式。此处使用带有模式的 `let` 语句对元组进行了解构。

将发送端移入一个新建线程并使其发送一个字符串，使新建线程可以与主线程进行通信：

```rust
use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    // 使用 move 将 tx 的所有权移动到闭包中，以便新建线程能够拥有 tx
    // 新建线程需要获得发送端的所有权，才能够通过通道发送信息
    thread::spawn(move || {
        let val = String::from("hi");
        // send 方法返回 Result<T, E> 类型
        // 如果接收端已被丢弃，无处发送值，发送操作将会返回错误
        // 此处调用 unwrap 使程序在发生错误时 Panic，在真实的应用中，则需要妥善处理此处的错误
        tx.send(val).unwrap();
    });

    // 当通道发送端关闭，recv 会返回一个错误表明不会再有新的值到来
    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

### `recv` vs `try_recv`

通道的接收端有两个有用的方法：`recv` 和 `try_recv`

`recv` 是 `receive` 的缩写，该方法会阻塞主线程的执行直到从通道中接收到值。一旦接收到值，`recv` 会在一个 `Result<T, E>` 中将其返回。当通道的发送端关闭，`recv` 将会返回错误表明不再有新值到来。

`try_recv` 不会阻塞，它会立即返回一个 `Result<T, E>`： `Ok` 值持有消息（ 如果可用的话 ），`Err` 值用来表示此时没有任何消息。如果线程在等待消息到来期间还有其他工作需要处理，`try_recv` 方法非常有用：可以编写循环对 `try_recv` 进行调用，如果收到可用消息则进行处理，否则处理一会儿其他工作直到再次检查。

运行代码：

```shell
Got: hi
```

## 通道与所有权转移

所有权规则在消息传递中所扮演的角色十分重要，因其有助于编写安全、并发的代码。自始至终在你的 Rust 程序中考虑所有权可以得到避免并发编程错误的好处。以下通过实验代码展示通道和所有权是怎样配合工作阻止问题产生的：

```rust
use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();

        // 一旦值被发送到其他线程，在接收它的线程中可能会被修改或者丢弃
        // 以下语句尝试在将 val 发送到其它线程后使用它，由于数据不一致或者不存在，有可能导致错误或者不可预料的结果
        println!("val is {}", val);
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}
```

编译错误：

```rust
error[E0382]: use of moved value: `val`
  --> src/main.rs:10:31
   |
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!("val is {}", val);
   |                               ^^^ value used here after move
   |
   = note: move occurs because `val` has type `std::string::String`,
    which does not implement the `Copy` trait
```

`send` 函数获取其参数的所有权，值被移动后，其所有权归接收者所有，这将防止无意中再次使用已发送的值。所有权系统会进行检查以确保一切正常。

## 发送多个值并观察接收者等待

之前的示例并未清楚展现两个独立线程之间通过通道相互对话。本示例做了一些修改，来证明代码是并行运行的：新建线程将会间隔 1 秒发送多个消息。

```rust
use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    // 主线程的 for 循环中没有任何暂停或延迟等待的代码，所以主线程是在等待接收来自新建线程中的值
    // 此处不再显式调用 recv 函数，而是将 rx 当作一个迭代器
    // 对于每一个接收到的值，将其打印出来。当通道关闭时，迭代也随之结束
    for received in rx {
        println!("Got: {}", received);
    }
}
```

运行结果：

```shell
Got: hi
Got: from
Got: the
Got: thread
```

## 通过克隆发送者创建多个生产者

之前提到 `mpsc` 是指 “多个生产者，单个消费者”，现在就来创建多个将值发送到同一个接受者的线程：

```rust
use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
  let (tx, rx) = mpsc::channel();
  // 创建新线程前，对通道的发送端调用 clone 方法。这将创建一个新的发送句柄，然后传递给新建线程
  let tx1 = mpsc::Sender::clone(&tx); // 克隆通道的发送端

  thread::spawn(move || {
      let vals = vec![
          String::from("hi"),
          String::from("from"),
          String::from("the"),
          String::from("thread"),
      ];

      for val in vals {
          tx1.send(val).unwrap();
          thread::sleep(Duration::from_secs(1));
      }
  });

  // 将原始发送端传递给第二个新建线程
  thread::spawn(move || {
      let vals = vec![
          String::from("more"),
          String::from("messages"),
          String::from("for"),
          String::from("you"),
      ];

      for val in vals {
          tx.send(val).unwrap();
          thread::sleep(Duration::from_secs(1));
      }
  });

  for received in rx {
      println!("Got: {}", received);
  }
}
```

运行代码，输出结果可能看起来像这样：

```shell
Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
```

输出结果也可能以其它顺序呈现，这取决于你的系统。如果修改不同线程中的 `thread::sleep` 方法参数，代码运行结果将会更加不确定。
