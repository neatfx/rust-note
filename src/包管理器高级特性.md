# 包管理器高级特性

到目前为止，我们仅仅使用了 Cargo 的基本功能来构建、运行以及测试代码，但是 Cargo 能做得更多。本章节将介绍用于实现以下目标的部分 Cargo 高级功能：

- 使用发布概要对构建过程进行自定义
- 发布库到 crate.io
- 使用工作区组织大型项目
- 安装来自 crate.io 的二进制文件
- 使用自定义命令扩展 Cargo

完整的 Cargo 功能说明可参考[文档](its documentation)

## 使用发布配置自定义构建

在 Rust 中，发布配置是包含不同自定义配置项的预定义配置，允许程序员在编译代码的不同选项上拥有更多控制权。每个参数的配置都独立于其它参数。

Cargo 有两种主要的配置：

- 当运行 `cargo build` 时 Cargo 采用 `dev` 配置 （ 定义包含了适合开发环境的默认值 ）
- 当运行 `cargo build --release` 时，Cargo 使用 `release` 配置（ 定义包含适合发布构建的默认值 ）

以下命令输出中的 `dev` 及 `release` 表明编译器使用了不同的构建配置：

```shell
$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
$ cargo build --release
    Finished release [optimized] target(s) in 0.0 secs
```

当 `Cargo.toml` 文件中找不到 `[profile.*]` 部分时，Cargo 会为每个应用的配置提供默认设置，通过为你想要自定义的配置添加 `[profile.*]` 部分，可以覆盖默认设置的任意子集。例如，位于 `dev` 及 `release` 配置中的 `opt-level` 设置的默认值。

```shell
[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
```

`opt-level` 设置用于控制 Rust 应用于代码的优化项的数量。过多的优化会增加编译时间，因此，如果处在开发阶段频繁编译代码，你会希望快速编译即使生成的代码运行较慢。这就是 `dev` 配置中的 `opt-level` 默认设置为 0 的原因。当准备好要发布代码，最好在编译时多花点一些时间。发布模式下只编译一次，但是编译后的程序需要反复运行，因此为了更快的运行速度，发布模式能够接受较长的编译时间。这也是 `opt-level` 在 `release` 配置中设置为 3 的原因。

通过在 `Cargo.toml` 中加入不同的值，可以覆盖任意默设置。例如，如果想要在开发配置中使用优化级别 1，可以添加以下两行添加到项目的 `Cargo.toml` 文件：

```shell
[profile.dev]
opt-level = 1
```

该代码将覆盖默认值 0，现在运行 `cargo run` 命令，Cargo 将使用默认 `dev` 配置叠加 `opt-level` 的自定义设置。因为 `opt-level` 被设置为 1 ，所以 Cargo 应用的优化处理将会多于默认数量，但不会像 `release` 配置一样多。

完整的配置选项列表以及每个配置的默认值可查阅[文档](https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections)

## 将 Crate 发布到 Crates.io

前面我们已经使用了来自 crates.io 的包作为项目依赖，但是也可以通过发布自己的包来与其他人分享代码。在 crates.io 注册的 crate 分发包源代码，因此它主要托管开源代码。

Rust 以及 Cargo 从一开始就提供了发布包的功能，帮助你发布包更容易。

### 提供良好的文档注释

```rust
   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

```shell
   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

```rust
//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
```

### 使用 `pub use` 导出 API

```rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -> SecondaryColor {
        // --snip--
        SecondaryColor::Orange
    }
}
fn main() {}
```

```rust
use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
```

```rust
//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
}

pub mod utils {
    // --snip--
}
```

```rust
use art::PrimaryColor;
use art::mix;

fn main() {
    // --snip--
}
```

### 设置 Crates.io 账户

```shell
cargo login abcdefghijklmnopqrstuvwxyz012345
```

### 为新 Crate 添加元数据

```shell
[package]
name = "guessing_game"
```

```shell
$ cargo publish
    Updating registry `https://github.com/rust-lang/crates.io-index`
warning: manifest has no description, license, license-file, documentation,
homepage or repository.
--snip--
error: api errors: missing or empty metadata fields: description, license.
```

```shell
[package]
name = "guessing_game"
license = "MIT"
```

```shell
[package]
name = "guessing_game"
version = "0.1.0"
authors = ["Your Name <you@example.com>"]
edition = "2018"
description = "A fun game where you guess what number the computer has chosen."
license = "MIT OR Apache-2.0"

[dependencies]
```

### 发布到 Crates.io

```shell
$ cargo publish
 Updating registry `https://github.com/rust-lang/crates.io-index`
Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
 Finished dev [unoptimized + debuginfo] target(s) in 0.19 secs
Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
```

### 发布已有 Crate 的新版本

### 使用 cargo yank 移除版本

```shell
cargo yank --vers 1.0.1
```

```shell
cargo yank --vers 1.0.1 --undo
```

## Cargo 工作区

项目开发过程中，库 `crate` 可能变得越来越大，会有将包拆分到多个库 `crates` 的想法。Cargo 提供了工作区功能帮助对多个协同开发的关联包进行管理。

### 创建工作区

工作区是一组共享同一 `Cargo.lock` 以及输出目录的包。组织工作区有多种方式，这里只演示一种常见的方式。示例是包含了一个二进制以及两个库的工作区。二进制提供主要功能，依赖于两个库。一个库提供了 `add_one` 函数，另一个库提供了 `add_two` 函数。这 3 个 `crates` 是同一个工作区的一部分。

首先为工作区创建一个新目录：

```shell
mkdir add
cd add
```

接下来，创建用于配置整个工作区的 `Cargo.toml` 文件。该文件不包含我们在其他 `Cargo.toml` 中见到过的 `[package]` 区块或者元数据。而是会以一个 `[workspace]` 区块开始，允许我们通过指定二进制 crate 路径添加工作区成员，本例中的路径是 `adder`：

```shell
[workspace]

members = [
    "adder",
]
```

在 `add` 目录内，使用 `cargo new` 创建 `addr` 二进制 `crate`：

```shell
$ cargo new adder
     Created binary (application) `adder` project
```

此时，可以使用 cargo build 命令对工作区进行构建，`add` 目录结构如下：

```shell
├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
```

工作区根目录有一个 `target` 目录用于放置编译产物，`adder` crate 没有自己的 `target` 目录。即使我们在 `adder` 目录内运行 `cargo build` 命令，编译后的文件依旧会出现在 `add/target` 目录而不是 `add/adder/target` 目录。Cargo 这样做是因为工作区中的 crates 是相互依赖的。如果 crate 拥有自己的 `target` 目录，那么 crate 将不得不重新编译同一工作区的其它 crates 来获取所需的编译结果文件到自身 `target` 目录。通过共享 `target` 目录，crates 能够避免不必要的重复构建。

### 在工作区中创建第二个 Crate

再次修改 Cargo.toml 文件，加入第二个 crate 成员：

```shell
[workspace]

members = [
    "adder",
    "add-one",
]
```

生成一个新的库 crate：

```shell
$ cargo new add-one --lib
     Created library `add-one` project
```

此时的 `add` 目录结构如下：

```shell
├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
```

在 add-one/src/lib.rs 文件中增加 add_one 函数：

```rust
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```

现在，工作区中有一个库 crate 了，我们可以使二进制 crate 依赖于库 crate。首先，需要添加一个关于 `add-one` 的路径依赖到 `adder/Cargo.toml`：

```shell
[dependencies]

add-one = { path = "../add-one" }
```

Cargo 并不假设工作区中的 crates 会相互依赖，因此需要我们显式指明 crates 之间的依赖关系。

下一步，在 `adder` crate 中使用 `add-one` crate 中的 `add_one` 函数：

```rust
use add_one;

fn main() {
    let num = 10;
    println!("Hello, world! {} plus one is {}!", num, add_one::add_one(num));
}
```

对工作区进行编译（在 add 目录下运行 cargo build 命令）：

```shell
$ cargo build
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68 secs
```

想要在 add 目录运行二进制 crate，需要使用 `-p` 参数 + 包名来指定使用工作区中的哪一个包：

```shell
$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
```

#### 在工作区中依赖一个外部 Crate

与 Cargo.toml 文件不同，工作区只有一个 Cargo.lock 文件，而不是在每个 crate 目录下都有。这确保了所有的 crates 使用相同版本的依赖。如果在 adder/Cargo.toml 以及 add-one/Cargo.toml 中添加 `rand` crate，这两个依赖将会被 Cargo 解析为同一版本并在 Cargo.lock 中记录。使工作区中的 crates 使用相同版本的依赖也意味着这些 crates 会保持相互兼容。

在 add-one crate 中加入 rand crate：

```shell
[dependencies]
rand = "0.5.5"
```

之后就可以在 add-one/src/lib.rs 中添加 use rand; 来使用此外部 crate。在 add 目录下运行 cargo build 对工作区进行编译：

```shell
$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
   --snip--
   Compiling rand v0.5.5
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18 secs
```

`Cargo.lock` 现在将包含 `rand` 依赖的信息（来自于 add-one）。尽管如此，此时在工作区的其它 crates 中是无法使用 `rand` crate 的，除非将 rand 加入要使用它的 crate 的 `Cargo.toml` 文件中。如果在 `adder/src/main.rs` 中使用了 `use rand;` 但是没有将 `rand` 依赖添加到 `adder/Cargo.toml` 文件，编译代码将会报错：

```shell
$ cargo build
   Compiling adder v0.1.0 (file:///projects/add/adder)
error: use of unstable library feature 'rand': use `rand` from crates.io (see
issue #27703)
 --> adder/src/main.rs:1:1
  |
1 | use rand;
```

在 `adder/Cargo.toml` 文件中指定 `rand` 依赖即可修复此错误。编译 `adder` crate 会把 `rand` 加入 `Cargo.lock` 中 `adder` 的依赖列表，但不会下载额外的 `rand` 副本。Cargo 确保工作区中的每个 crate 使用相同版本的 `rand` 依赖，这不仅节省了空间同时还保证了工作区中的 crates 能够相互兼容。

#### 在工作区中添加测试

修改文件 add-one/src/lib.rs 内容：

```rust
fn main() {
pub fn add_one(x: i32) -> i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
}
```

在 `add` 目录中运行 `cargo test` 命令：

```shell
$ cargo test
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-f88af9d2cc175a5e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

输出的第一段显示 add-one crate 中的 it_works 测试通过。之后的部分显示 adder crate 中没有测试，最后一段显示 add-one crate 中没有文档测试。在此类组织结构的工作区中运行 `cargo test` 会为工作区中所有的 crates 运行测试。

通过指定参数 `-p` 及 crate 也可以为工作区中某个特定的 crate 运行测试：

```shell
$ cargo test -p add-one
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

输出显示 `cargo test` 只运行了 `add-one` crate 中的测试，但没有有运行 `adder` 中的测试。

如果将工作区中的 crates 发布到 crates.io，需要单独发布工作区中每个 crate。`cargo publish` 命令没有 `--all` 或者 `-p`，所以必须切换到每个 crate 目录并运行 `cargo publish` 进行发布。

随着项目不断增长应当考虑使用工作区：相比一大堆代码，小的独立组件更容易理解。而且，如果 crates 经常同时变动，把它们放在同一个工作区中，会使它们之间的协同变得更容易。

## 使用 `Cargo install` 从 Crates.io 安装二进制文件

`cargo install` 命令允许我们在本地安装和使用二进制 `crates`。对于 Rust 开发者来说它是一种安装其他人在 `crates.io` 上分享的工具的便捷方式，而非想要取代系统包。注意，只能安装具有二进制目标的包。相对于无法独立运行但适合被包含进其他程序中的 “库目标”，“二进制目标” 是由包含 `src/main.rs` 的 `crate` 或另一个被指定为二进制的文件创建的可执行程序。通常，README 文件中会包含与 `crates` 有关的信息，比如某个`crate` 是否是一个库，拥有二进制目标，或两者都有。

所有使用 `cargo install` 安装的二进制文件都存放于安装根目录下的 `bin` 文件夹中。如果使用 `rustup.rs` 安装 Rust，并且无任何自定义配置，这个安装目录将会是 `$HOME/.cargo/bin`。确保此目录包含在 `$PATH` 环境变量中，以便于能够运行使用 `cargo install` 安装的程序。

例如，已知一个使用 Rust 实现的名为 “ripgrep” 的 grep 工具，用于搜索文件。如果想安装 `ripgrep`，可执行以下操作：

```shell
$ cargo install ripgrep
Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading ripgrep v0.3.2
 --snip--
   Compiling ripgrep v0.3.2
    Finished release [optimized + debuginfo] target(s) in 97.91 secs
  Installing ~/.cargo/bin/rg
```

输出的最后一行显示了二进制文件的安装位置和名称，在 `ripgrep` 这个例子中二进制的名字是 `rg`。像之前提到的那样，只要 `$PATH` 中存在此安装目录，接下来就可以运行 `rg --help` ，开始使用更快、更具 Rust 风格的工具来搜索文件。

## 使用自定义命令扩展 Cargo

Cargo 被设计为无需修改即可使用新的子命令进行扩展。如果在 `$PATH` 中有一个名为 `cargo-something` 的二进制文件，你可以通过 `cargo something` 命令运行它就好像它是 Cargo 的子命令一样。当运行 `cargo --list` 命令时，像这样的自定义命令也会被列出来。能够使用 `cargo install` 命令安装扩展然后就像内置 Cargo 工具一样运行是一个 Cargo 设计中超级便利的好处。

## 总结

使用 Cargo 及 crates.io 分享代码是构建为不同类型任务提供支持的 Rust 生态系统的一部分。Rust 标准库小而稳定，但是 crates 易于分享、使用并且在与语言本身不同的时间线上改进。
