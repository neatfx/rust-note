# 包管理器高级特性

到目前为止，我们仅仅使用了 Cargo 的基本功能来构建、运行以及测试代码，但是 Cargo 能做得更多。本章节将介绍用于实现以下目标的部分 Cargo 高级功能：

- 使用发布概要对构建过程进行自定义
- 发布库到 crate.io
- 使用工作区组织大型项目
- 安装来自 crate.io 的二进制文件
- 使用自定义命令扩展 Cargo

完整的 Cargo 功能说明可参考[文档](its documentation)

## 使用发布配置自定义构建

在 Rust 中，发布配置是包含不同自定义配置项的预定义配置，允许程序员在编译代码的不同选项上拥有更多控制权。每个参数的配置都独立于其它参数。

Cargo 有两种主要的配置：

- 当运行 `cargo build` 时 Cargo 采用 `dev` 配置 （ 定义包含了适合开发环境的默认值 ）
- 当运行 `cargo build --release` 时，Cargo 使用 `release` 配置（ 定义包含适合发布构建的默认值 ）

以下命令输出中的 `dev` 及 `release` 表明编译器使用了不同的构建配置：

```shell
$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
$ cargo build --release
    Finished release [optimized] target(s) in 0.0 secs
```

当 `Cargo.toml` 文件中找不到 `[profile.*]` 部分时，Cargo 会为每个应用的配置提供默认设置，通过为你想要自定义的配置添加 `[profile.*]` 部分，可以覆盖默认设置的任意子集。例如，位于 `dev` 及 `release` 配置中的 `opt-level` 设置的默认值。

```shell
[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
```

`opt-level` 设置用于控制 Rust 应用于代码的优化项的数量。过多的优化会增加编译时间，因此，如果处在开发阶段频繁编译代码，你会希望快速编译即使生成的代码运行较慢。这就是 `dev` 配置中的 `opt-level` 默认设置为 0 的原因。当准备好要发布代码，最好在编译时多花点一些时间。发布模式下只编译一次，但是编译后的程序需要反复运行，因此为了更快的运行速度，发布模式能够接受较长的编译时间。这也是 `opt-level` 在 `release` 配置中设置为 3 的原因。

通过在 `Cargo.toml` 中加入不同的值，可以覆盖任意默设置。例如，如果想要在开发配置中使用优化级别 1，可以添加以下两行添加到项目的 `Cargo.toml` 文件：

```shell
[profile.dev]
opt-level = 1
```

该代码将覆盖默认值 0，现在运行 `cargo run` 命令，Cargo 将使用默认 `dev` 配置叠加 `opt-level` 的自定义设置。因为 `opt-level` 被设置为 1 ，所以 Cargo 应用的优化处理将会多于默认数量，但不会像 `release` 配置一样多。

完整的配置选项列表以及每个配置的默认值可查阅[文档](https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections)

## 将 Crate 发布到 Crates.io

## Cargo 工作区

### 创建工作区

```shell
mkdir add
cd add
```

```shell
[workspace]

members = [
    "adder",
]
```

```shell
$ cargo new adder
     Created binary (application) `adder` project
```

```shell
├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
```

### 在工作区中创建第二个 Crate

```shell
[workspace]

members = [
    "adder",
    "add-one",
]
```

```shell
$ cargo new add-one --lib
     Created library `add-one` project
```

```shell
├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
```

```rust
pub fn add_one(x: i32) -> i32 {
    x + 1
}
```

```shell
[dependencies]

add-one = { path = "../add-one" }
```

```rust
use add_one;

fn main() {
    let num = 10;
    println!("Hello, world! {} plus one is {}!", num, add_one::add_one(num));
}
```

```shell
$ cargo build
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68 secs
```

```shell
$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
```

#### 在工作区中依赖一个外部 Crate

```shell
[dependencies]
rand = "0.5.5"
```

```shell
$ cargo build
    Updating crates.io index
  Downloaded rand v0.5.5
   --snip--
   Compiling rand v0.5.5
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18 secs
```

```shell
$ cargo build
   Compiling adder v0.1.0 (file:///projects/add/adder)
error: use of unstable library feature 'rand': use `rand` from crates.io (see
issue #27703)
 --> adder/src/main.rs:1:1
  |
1 | use rand;
```

#### 在工作区中添加测试

```rust
#![allow(unused_variables)]
fn main() {
pub fn add_one(x: i32) -> i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
}
```

```shell
$ cargo test
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-f88af9d2cc175a5e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

```shell
$ cargo test -p add-one
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

## 使用 `Cargo install` 从 Crates.io 安装二进制文件

`cargo install` 命令允许我们在本地安装和使用二进制 `crates`。对于 Rust 开发者来说它是一种安装其他人在 `crates.io` 上分享的工具的便捷方式，而非想要取代系统包。注意，只能安装具有二进制目标的包。相对于无法独立运行但适合被包含进其他程序中的 “库目标”，“二进制目标” 是由包含 `src/main.rs` 的 `crate` 或另一个被指定为二进制的文件创建的可执行程序。通常，README 文件中会包含与 `crates` 有关的信息，比如某个`crate` 是否是一个库，拥有二进制目标，或两者都有。

所有使用 `cargo install` 安装的二进制文件都存放于安装根目录下的 `bin` 文件夹中。如果使用 `rustup.rs` 安装 Rust，并且无任何自定义配置，这个安装目录将会是 `$HOME/.cargo/bin`。确保此目录包含在 `$PATH` 环境变量中，以便于能够运行使用 `cargo install` 安装的程序。

例如，已知一个使用 Rust 实现的名为 “ripgrep” 的 grep 工具，用于搜索文件。如果想安装 `ripgrep`，可执行以下操作：

```shell
$ cargo install ripgrep
Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading ripgrep v0.3.2
 --snip--
   Compiling ripgrep v0.3.2
    Finished release [optimized + debuginfo] target(s) in 97.91 secs
  Installing ~/.cargo/bin/rg
```

输出的最后一行显示了二进制文件的安装位置和名称，在 `ripgrep` 这个例子中二进制的名字是 `rg`。像之前提到的那样，只要 `$PATH` 中存在此安装目录，接下来就可以运行 `rg --help` ，开始使用更快、更具 Rust 风格的工具来搜索文件。

## 使用自定义命令扩展 Cargo

Cargo 被设计为无需修改即可使用新的子命令进行扩展。如果在 `$PATH` 中有一个名为 `cargo-something` 的二进制文件，你可以通过 `cargo something` 命令运行它就好像它是 Cargo 的子命令一样。当运行 `cargo --list` 命令时，像这样的自定义命令也会被列出来。能够使用 `cargo install` 命令安装扩展然后就像内置 Cargo 工具一样运行是一个 Cargo 设计中超级便利的好处。

## 总结

使用 Cargo 及 crates.io 分享代码是构建为不同类型任务提供支持的 Rust 生态系统的一部分。Rust 标准库小而稳定，但是 crates 易于分享、使用并且在与语言本身不同的时间线上改进。
