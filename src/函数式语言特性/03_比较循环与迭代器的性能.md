# 比较循环与迭代器的性能

我们需要知道哪个版本的 `search` 函数更快以决定使用循环还是迭代器：直接使用 `for` 循环的版本还是使用迭代器的版本。

我们运行了一个性能测试，将阿瑟·柯南·道尔的《福尔摩斯探案集》的全部内容加载进一个 `String` 并在其中查找单词 “*the*”。两个版本的性能测试结果如下：

```shell
test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
```

迭代器版本还要稍微快一点！这里不对测试代码做讲解，因为该测试的目的不是为了证明两个版本是等同的，而是为了直观感受两种实现方式的性能差异。

对于一个更全面的性能测试来说，还应当检查不同长度的文本、不同的搜索单词、不同长度的单词以及所有其他各种变化。不过这里所要表达的是：迭代器，尽管是一个高级抽象，其编译后的代码与你自己手写的低级代码大致相同。迭代器是 Rust 具有的零成本抽象（ zero-cost abstractions ）之一，零成本抽象意味着抽象不会强加额外的运行时开销，这与 `Bjarne Stroustrup`（ 设计实现了 C++ ）在 《 Foundations of C++ 》（ 2012 年 ）中所定义的 *零开销*（ zero-overhead ）如出一辙：

>通常来说，C++ 的实现遵循了零开销原则：不要为你不用的东西买单。进一步讲：对于要用的，你拿不出更好的代码。

作为另一个例子，下面代码取自于某音频解码器。解码算法使用线性预测数学运算（ *linear prediction mathematical operation* ）根据先前样本的线性函数对将来的值进行估算。代码使用迭代器链对作用域中的三个变量进行一些数学计算：一个持有数据 `slice` 的 `buffer`、一个具有 12 个元素的数组 `coefficients` 和一个代表位移位数的 `qlp_shift`。示例中声明了这些变量但并未赋值。尽管这些代码在其上下文之外没有什么意义，却不失为一个简练的演示 Rust 如何将高层想法转换为底层代码的真实例子：

```rust
let buffer: &mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&buffer[i - 12..i])
                                 .map(|(&c, &s)| c * s as i64)
                                 .sum::<i64>() >> qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
```

为了计算 `prediction` 的值，代码对 `coefficients` 中的 12 个值进行遍历，使用 `zip` 方法将这些系数值与 `buffer` 的前 12 个值进行配对。然后将每一对值相乘，再将所有结果相加，最后将总和中的位向右移动 `qlp_shift` 位。

像音频解码器这样的程序中的计算通常极为看重性能。这里，我们创建了一个迭代器，使用了两个适配器，然后对值进行消费值。那么 Rust 代码将会被编译成什么样的汇编代码呢？好吧，在编写本书的时候，它会被编译成与手写汇编代码相同的代码。与遍历 `coefficients` 中的值相对应的代码完全没有使用循环：Rust 知道有 12 次迭代，所以它“展开”（ *unroll* ）了循环。展开是一种优化，用于移除循环控制代码的开销而不是为每个循环迭代生成重复代码。

所有系数都被储存在寄存器中，这意味着访问这些值会非常快。也没有运行时数组访问边界检查。所有这些 Rust 能够提供的优化使得结果代码极为高效。现在知道这些之后，放心大胆地使用迭代器和闭包吧！它们会使得代码看起来更高级，但并不会因此招致运行时性能惩罚。

## 总结

闭包和迭代器是受函数式编程语言概念启发的 Rust 功能。它们为 Rust 以底层的性能清楚表达高层想法的能力作出了贡献。闭包和迭代器的实现达到了不影响运行时性能的程度。这正是 Rust 致力于提供的零成本抽象目标的一部分。
