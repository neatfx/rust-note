# 并发编程

使并发编程变得安全且高效是 Rust 的设计目标之一。

Rust 通过所有权和类型检查在编译时检测并发错误，拒绝编译有问题（ 数据竞争、无效引用等 ）的代码并提供参考信息，避免将难以跟踪的并发BUG推迟到运行时解决。一旦代码编译通过，就应当坚信它们能够正确运行于多线程环境，不会出现其他语言中常见的并发 BUG，可以放心对代码进行重构。

Rust 自带处理并发的内容很少，适用多线程场景的并发方案多由 Crate 实现，且比标准库发展的更快。

很多语言提供的并发处理方案都很有特色。例如，Erlang 提供了优雅的消息传递并发功能，但只有模糊不清的在线程间共享状态的方法。对于高级语言来说，牺牲底层控制提供抽象便利是其价值所在，因此只实现部分解决方案是合理的策略。然而，对于底层语言，则希望在任何给定情况下有最好的性能以及更少的硬件抽象。因此，Rust 提供了多种工具，贴近实际情况和需求处理并发。

本章节内容：

- 创建线程同时运行多段代码
- 消息传递并发（ 通道被用来在线程间传递消息 ）
- 共享状态并发（ 多个线程可以访问同一片数据 ）
- `Sync` 和 `Send` 特质（ 将 Rust 的并发保证扩展到用户自定义或标准库提供的类型中 ）
