# 变量与可变性

## 变量

### 不可变变量

变量默认是不可改变的

不可变意味着当阅读和编写代码时，无需追踪一个值如何及在何处被改变，从而使得代码易于推导

```rust
fn main() {
  let x = 5;
  x = 6; // 编译时错误: cannot assign twice to immutable variable x
}
```

### 可变变量

通过 `mut` 使默认不可改变的变量可变

```rust
fn main() {
  let mut y = 7;
  y = 8; // 编译通过
}
```

## 可变性取舍

- 使用大型数据结构时，适当地使用可变变量，可能比复制和返回新分配的实例更快。
- 对于较小的数据结构，总是创建新实例，采用更偏向函数式的编程风格（ 不可变变量 ），牺牲一些性能换取更好的代码可读性可能是值得的。

## 变量与常量的区别

- 常量始终是不可变的，不允许对常量使用 `mut`
- 常量使用 `const` 关键字声明，并且必须标注值的类型
- 常量可以在任何作用域中声明，包括全局作用域
- 常量只能被设置为常量表达式，而不能是函数调用的结果，或任何其他只能在运行时计算出的值

将程序中的硬编码值声明为常量，利于后来的代码维护人员了解值的含义（ 有意义的常量命名 ），并且如果将来需要修改硬编码值，也只需修改一处常量值。

## 遮蔽

定义一个与之前变量同名的新变量，新变量会遮蔽（ Shadowing ）之前的变量，可重复使用 `let` 关键字进行多次遮蔽

```rust
let x = 5;
let x = x + 1;
let x = x * 2; // 12
```

### `Shadowing` 与 `mut` 的区别

- 不使用 let 关键字对变量重新赋值将得到编译时错误
- 变量类型是否可变

#### `Shadowing` - 变量类型可变

```rust
  let spaces = "   "; // 字符串类型
  let spaces = spaces.len(); // 数字类型
```

#### `mut` - 变量类型不可变

```rust
  let mut spaces = "   ";

  // 编译时错误: mismatched types
  spaces = spaces.len(); // expected &str, found usize
  ```
