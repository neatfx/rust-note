# 字符串

字符串（ String ）是由字节的集合以及字节处理方法组合实现的。

Rust 中的字符串不如想象中的那样简单是因为：

- 语言对处理数据的要求更严格（ 提前预防错误的产生 ）
- 字符串本身具有复杂性
- 涉及编码问题

## 字符串的概念

Rust 核心语言中只有一种字符串类型 `str`（ 字符串 `slice` ） ，通常以被借用的形式（ `&str` ）出现，用来指代一些储存在某处的 `UTF-8` 编码字符串数据的引用。

`String` 类型（ 可增长的、可变的、有所有权的、UTF-8 编码的字符串类型 ）并不属于核心语言类型，而是由标准库提供的。

在 Rust 中，谈及字符串通常指 `String` 和字符串 `slice` 两种类型，它们都是 `UTF-8` 编码的。

Rust 标准库以及 Crate 中提供了更多与字符串相关的类型，比如 `OsString`、`OsStr`、`CString`、`CStr`，这些以 `String` 或是 `Str` 结尾的命名方式对应了这些字符串类型所提供的所有权和可借用的字符串变体，这些字符串类型能够以不同的编码或内存表现形式存储文本内容。

## 新建

```rust
// 新建空 String
let mut s = String::new();

let data = "initial contents"; // 字符串字面值（ 实现了 Display 特质 ）

// 3种方式从字符串字面值创建 String
let s = data.to_string();
let s = "initial contents".to_string();
let s = String::from("initial contents");
```

## 更新

### 附加字符串

```rust
let mut s = String::from("foo");
s.push_str("bar"); // foobar
```

```rust
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2); // `push_str` 方法参数使用字符串 `slice` 类型，不需要获取所有权

println!("s2 is {}", s2); // `push_str` 方法不获取 s2 的所有权，因此可以正常执行打印
```

### 附加单独字符

```rust
let mut s = String::from("lo");
s.push('l'); // lol
```

### 拼接字符串

#### 使用 `+` 运算符

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!"); // &s2 的类型是 &String 而不是 &str
let s3 = s1 + &s2; // 注意 s1 被移动了，不能继续使用
```

该运算符调用的方法签名类似 `fn add(self, s: &str) -> String {...}`，表示使用字符串 `s2` 的引用与字符串 `s1` 相加。

`&s2` 的类型（ `&String` ）与形参类型（ `&str` ）不符，编译仍可通过是因为 Rust 将 `&s2` 强制转换成了 `&s2[..]`，此操作并没有获取 `s2` 的所有权，所以操作之后 `s2` 仍然是有效的。

另外，`add` 获取了 `self` 的所有权，因为 `self` 没有使用 `&`，这意味着 `s1` 的所有权将被移动到 `add` 调用中，之后不再有效。所以 `let s3 = s1 + &s2;` 语句实际上会获取 `s1` 的所有权，附加上从 `s2` 中拷贝的内容，并返回结果的所有权。这个实现比多次复制数据更加高效。

#### 使用 `format!` 宏

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

// 混合了大量 `+` 和 `"` 的表达式不够直观
let s = s1 + "-" + &s2 + "-" + &s3;

// 使用宏改写更直观！并且不会获取任何参数的所有权！
let s = format!("{}-{}-{}", s1, s2, s3);
```

## 索引字符串

```rust
let s1 = String::from("hello");
let h = s1[0]; // 报错： Rust 字符串不支持索引
```

Rust 字符串不支持索引的原因：

- 字符串索引返回的类型是不明确的，为了避免返回错误值造成隐性 BUG，Rust 的选择是不编译这些代码，防患于未然。
- 性能因素

### 字符串索引返回的类型

字符串索引可返回类型包括：字节值、字符、字形簇、字符串 `slice`

#### 内部存储模式

`String` 是一个 `Vec<u8>` 的封装

```rust
// 储存字符串的 Vec 的长度是 4 个字节（ 每个字母的 UTF-8 编码占用一个字节 ）
let len = String::from("Hola").len();

// 储存字符串的 Vec 的长度是 24 个字节（ 使用 UTF-8 编码所需的字节数 ）
// 每个 Unicode 标量值需要两个字节存储
let len = String::from("Здравствуйте").len();
```

字符串字节值的索引并不总是对应一个有效的 `Unicode` 标量值：

```rust
// 当使用 UTF-8 编码时，З 的第一个字节 208，第二个是 151
// 所以 answer 的值实际上是 208（ 字节索引 0 位置对应的唯一数据 ）
// 而 208 并不是期望返回的
let hello = "Здравствуйте";
let answer = &hello[0]; // 208
```

#### 字节、标量值和字形簇

从 Rust 的角度有三种方式可以理解字符串：字节、标量值和字形簇

从字节的角度：

```shell
# 共有 18 个字节，即计算机最终会储存的数据
[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164,
 164, 224, 165, 135]
```

从 `Unicode` 标量值的角度：

```shell
# 类似 Rust 的 char 类型
# 共 6 个 `char`，第四个和第六个不是字母，是发音符号，本身并没有任何意义
['न', 'म', 'स', '्', 'त', 'े']
```

从以字形簇的角度：

```shell
# 得到人们所说的构成这个单词的四个字母
["न", "म", "स्", "ते"]
```

Rust 不关心存储内容是何种人类语言，而是提供了多种方式来解释原始字符串数据，供程序自由选择。

### 性能因素

索引操作预期总是需要常数时间 `O(1)`，由于 Rust 需要检查从字符串开头到索引位置的内容来确定有多少有效字符，`String` 不可能保证这样的性能。

## 字符串 `slice`

```rust
let hello = "Здравствуйте";

// s 的类型为 &str, 这些字母长度是两个字节，取字符串的头四个字节结果即为 “Зд”
let s = &hello[0..4];
```

尝试获取  `&hello[0..1]` 将会 panic，与访问 `Vector` 无效索引的表现一致。

## 遍历

### 从字符串中返回 char 类型的  Unicode 标量值

```rust
// 顺序打印 6 个 char 类型的值
for c in "नमस्ते".chars() {
    println!("{}", c);
}
```

### 从字符串中返回原始字节

不过需要注意有效的 Unicode 标量值可能会由不止一个字节组成

```rust
// 打印组成 String 的 18 个字节
for b in "नमस्ते".bytes() {
    println!("{}", b);
}
```

### 从字符串中获取字形簇

此操作比较复杂，Rust 标准库并没有提供该功能，如需要可找到供该功能的 Crate
