# 高级特质

本节内容大部分都很少见。关联类型的部分比较适中 - 比本书中的其它内容要少见，但比本节中的其它很多内容更为常见。

## 使用关联类型在特质定义中指定占位符类型

关联类型（ *associated types* ）将类型占位符与特质连接在一起，从而使特质方法定义可以使用这些占位符类型。特质的实现者会为特定实现指定要在此类型所在之处使用的具体类型。我们可以使用关联类型来定义一个使用多种类型的特质，此特质在被实现之前无需知道这些类型具体是什么。

一个使用关联类型的特质的例子是标准库提供的 `Iterator` 特质：

```rust
pub trait Iterator {
    type Item; // 关联类型，Item 是一个占位类型，替代遍历值的类型，其具体类型将由特质的实现者指定

    // 不论 Item 的具体类型是什么，next 方法都会返回一个包含该具体类型值的 Option
    fn next(&mut self) -> Option<Self::Item>;
}
```

关联类型的概念看起来类似泛型，因为它允许定义一个函数而不指定其可以处理的类型。那么为什么要使用关联类型呢？以下通过示例来分析两者的不同之处。

在 `Counter` 结构体上实现 `Iterator` 特质（ 定义中使用了关联类型 ）：

```rust
impl Iterator for Counter {
    type Item = u32;

    fn next(&mut self) -> Option<Self::Item> {
        // --snip--
```

使用泛型的假想定义：

```rust
pub trait Iterator<T> {
    fn next(&mut self) -> Option<T>;
}
```

使用关联类型与使用泛型的区别在使用泛型时，需要在每一个实现中标注类型。因为我们既可以 `impl Iterator<u32> for Counter` 也可以 `impl Iterator<String> for Counter`，或任何其它类型，因此，使用泛型会导致可能有多个特质实现。换句话说，当特质具有泛型参数时，它会被一个类型多次实现，每次实现都改变泛型参数的具体类型。当使用 `Counter` 上的 `next` 方法时，必须提供类型注解来表明希望使用 `Iterator` 的哪一个实现。

使用关联类型则无需标注类型因为不能在类型上多次实现特质。只能选择一次 `Item` 会是什么类型，因为只能有一个 `impl Iterator for Counter`。当调用 `Counter` 上的 `next` 方法时不必到处指定我们需要一个使用 `u32` 值的迭代器。

## 默认泛型类型参数及运算符重载

使用泛型类型参数时，可为泛型指定一个默认的具体类型。如果默认类型可用的话，就不需要特质的实现者再去指定一个具体类型。在声明泛型类型时使用 `<PlaceholderType=ConcreteType>` 语法为泛型类型指定默认类型。

运算符重载（ *Operator overloading* ）是指特定情况下对运算符（ 比如 `+` ）的行为进行自定义的操作。运算符重载非常适合用来演示默认泛型类型参数这一技术的用处。

Rust 并不允许创建自定义运算符或重载任意运算符，不过可以通过实现与运算符关联的特质来对 `std::ops` 中列出的操作及对应的特质进行重载。

以下示例展示了如何在 `Point` 结构体上实现 `Add` 特质来重载 `+` 运算符，从而实现将两个 `Point` 实例相加：

```rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    // `Add` 特质有一个名为 `Output` 的关联类型，用来决定 `add` 方法的返回类型
    type Output = Point;

    // `add` 方法将两个 `Point` 实例的 `x` 值和 `y` 值分别相加来创建一个新的 `Point`
    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
```

此代码中的默认泛型类型位于 `Add` 特质中，定义如下：

```rust
// 这看来很熟悉：一个带有一个方法和一个关联类型的特质。
// 陌生的部分是尖括号中的 `RHS=Self`：此语法被称为默认类型参数（ *default type parameters* ）
// `RHS` （ “right hand side” 的缩写 ）是一个泛型类型参数，用于定义 `add` 方法中的 `rhs` 参数
// 如果实现 `Add` 特质时不指定 `RHS` 的具体类型，其类型将是默认的 `Self` 类型，也就是在其上实现 `Add` 的类型
trait Add<RHS=Self> {
    type Output;

    fn add(self, rhs: RHS) -> Self::Output;
}
```

当为 `Point` 实现 `Add` 特质时，使用了默认的 `RHS`，因为我们希望将两个 `Point` 实例相加。下面看一个使用自定义 `RHS` 类型实现 `Add` 特质的例子。

有两个存放不同单位值的结构体：`Millimeters` 和 `Meters`。我们希望将毫米值与米值相加，并让 `Add` 的实现正确处理转换。我们可以使用 `Meters` 作为 `RHS` 为 `Millimeters` 实现 `Add` 特质，示例如下：

```rust
use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

// 指定 `impl Add<Meters>` 来设定 `RHS` 类型参数的值而不是使用默认的 `Self`
impl Add<Meters> for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -> Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
```

使用默认参数类型的两种主要方式：

- 在不破坏现有代码的前提下对类型进行扩展
- 允许在大多数用户都不需要的特定情况下进行自定义

标准库的 `Add` 特质属于第二个用途的一个例子：通常，你会将两个相似的类型相加，不过 `Add` 特质提供了额外的自定义能力。在 `Add` 特质定义中使用默认类型参数意味着大部分时候无需指定额外的参数。换句话说，不需要任何实现的样板代码，这样使用特质就更容易了。

第一个用途与第二个类似，但相反：如果想要为现有特质增加类型参数，可为其提供一个默认类型以允许在不破坏现有实现代码的基础上对特质的功能进行扩展。

## 完全限定语法与消除歧义：调用同名方法

```rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}
```

```rust
fn main() {
    let person = Human;
    person.fly();
}
```

```rust
fn main() {
    let person = Human;
    Pilot::fly(&person);
    Wizard::fly(&person);
    person.fly();
}
```

```bash
This is your captain speaking.
Up!
*waving arms furiously*
```

```rust
trait Animal {
    fn baby_name() -> String;
}

struct Dog;

impl Dog {
    fn baby_name() -> String {
        String::from("Spot")
    }
}

impl Animal for Dog {
    fn baby_name() -> String {
        String::from("puppy")
    }
}

fn main() {
    println!("A baby dog is called a {}", Dog::baby_name());
}
```

```bash
A baby dog is called a Spot
```

```rust
fn main() {
    println!("A baby dog is called a {}", Animal::baby_name());
}
```

```bash
error[E0283]: type annotations required: cannot resolve `_: Animal`
  --> src/main.rs:20:43
   |
20 |     println!("A baby dog is called a {}", Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^
   |
   = note: required by `Animal::baby_name`
```

```rust
fn main() {
    println!("A baby dog is called a {}", <Dog as Animal>::baby_name());
}
```

```bash
A baby dog is called a puppy
```

```bash
<Type as Trait>::function(receiver_if_method, next_arg, ...);
```

## 利用父级特质在特质中使用其它特质的功能

```bash
**********
*        *
* (1, 3) *
*        *
**********
```

```rust

#![allow(unused_variables)]
fn main() {
  use std::fmt;

  trait OutlinePrint: fmt::Display {
      fn outline_print(&self) {
          let output = self.to_string();
          let len = output.len();
          println!("{}", "*".repeat(len + 4));
          println!("*{}*", " ".repeat(len + 2));
          println!("* {} *", output);
          println!("*{}*", " ".repeat(len + 2));
          println!("{}", "*".repeat(len + 4));
      }
  }
}
```

```rust
#![allow(unused_variables)]
fn main() {
  trait OutlinePrint {}
  struct Point {
      x: i32,
      y: i32,
  }

  impl OutlinePrint for Point {}
}
```

```bash
error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --> src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;
try using `:?` instead if you are using a format string
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
```

```rust
use std::fmt;

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}
```

## 使用 `Newtype` 模式在外部类型上实现外部特质

```rust
use std::fmt;

struct Wrapper(Vec<String>);

impl fmt::Display for Wrapper {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "[{}]", self.0.join(", "))
    }
}

fn main() {
    let w = Wrapper(vec![String::from("hello"), String::from("world")]);
    println!("w = {}", w);
}
```
