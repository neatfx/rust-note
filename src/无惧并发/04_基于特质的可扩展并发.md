# 基于 `Sync` 以及 `Send` 特质的可扩展并发

值得注意的是，Rust 语言本身提供的并发功能很少。到目前本章讨论的几乎所有内容都来自于标准库。这也意味着并发处理的方案选择不受标准库或语言限制，可以编写自己的并发功能或者使用他人提供的并发解决方案。

尽管如此，标准库 `std::marker` 中的 `Sync` 和 `Send` 特质这两个并发概念还是被内置到了 Rust 语言中。

<!-- 它们允许 Rust 的并发保证扩展到用户定义或者标准库中提供的类型中。 -->

## `Send` 允许在线程间转移所有权

`Send` 标记特质表明类型的所有权可以在线程间转移。几乎所有的 Rust 类型都是 `Send` 的。不过有一些例外，比如智能指针 `Rc<T>` 类型：因为如果克隆 `Rc<T>` 的值并尝试将克隆的所有权转移到另一个线程，两个线程可能会同时对引用计数进行更新（ 这将引发错误，而解决方案是使用带有性能惩罚的原子引用计数方案 ）。因此，`Rc<T>` 被实现为用于不愿为线程安全接受性能惩罚的单线程场景。

所以，Rust 类型系统和 `trait bound` 确保绝不会意外非安全地跨线程发送 `Rc<T>` 值。在之前的示例中，当尝试在线程间发送 `Rc<T>` 时，会得到错误：

```shell
the trait Send is not implemented for Rc<Mutex<i32>>`。
```

在换用标记为 `Send` 的 `Arc<T>` 之后，代码可通过编译。

任何完全由 `Send` 类型组成的类型也会被自动标记为 `Send`，除了裸指针（ raw pointer ）以外，几乎所有的原始类型都是 `Send` 的。

## `Sync` 允许多线程访问

`Sync` 标记特质表明类型可以安全的在多个线程中拥有其值的引用。换句话说，对于任意类型 `T`，如果 `&T` （ 指向 T 的引用 ） 是 `Send` 的话，那么 `T` 就是 `Sync` 的。这意味着引用可以被安全地发送到其它线程。与 `Send` 类似，Rust 中的基本类型都是 `Sync` 的，完全由 `Sync` 类型组成的类型也是 `Sync` 的。

智能指针 `Rc<T>` 也不是 `Sync` 的，这与其不是 `Send` 的原因相同。`RefCell<T>` 和相关地 `Cell<T>` 类型家族都不是 `Sync` 的。`RefCell<T>` 中实现的运行时借用检查并非线程安全的。智能指针 `Mutex<T>` 是 `Sync` 的，可被用于在多个线程中共享访问数据。

## 手动实现 `Send` 和 `Sync` 是不安全的

由 `Send` 和 `Sync` 组成的类型，会自动被标记为是 `Send` 和 `Sync` 的，因而不需要手动实现 `Send` 和 `Sync` 特质。标记特质甚至无需实现任何方法，它们只对加强与并发相关的不可变性有用。

手动实现这些特质涉及实现非安全 Rust 代码，使用非安全 Rust 代码的相关内容将在 “高级特性” 章节讨论。当前的重点是，在构建新的组成部分不含 `Send` 和 `Sync` 的并发类型时，需要仔细考虑以维持并发安全保证。在 [The Rustonomicon](https://doc.rust-lang.org/stable/nomicon/) 中可以找到更多与此相关的内容。

## 总结

Rust 标准库提供了用于消息传递的通道以及 `Mutex<T>` 和 `Arc<T>` 这样的智能指针类型，它们可安全用于并发上下文。类型系统以及借用检查确保使用这些解决方案的代码不会因为数据竞争或者无效引用而终止。一旦代码被编译，便可确信其将在多个线程上欢快地运行，不会有其他语言中常见的那些难以追踪的 BUG 出现。并发编程不再是令人畏惧的概念：放心大胆地为程序加入并发功能吧！
