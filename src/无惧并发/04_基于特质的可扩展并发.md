# 基于 `Sync` 以及 `Send` 特质的可扩展并发

Rust 本身提供的并发相关的内容很少，之前讨论的几乎所有内容都来自标准库。这同时意味着并发方案不受标准库或语言限制，可以自己编写并发功能或者使用别人编写的并发功能。

标准库 `std::marker` 中的 `Sync` 和 `Send` 特质是两个内嵌于 Rust 语言中的并发概念。

它们允许 Rust 的并发保证能被扩展到用户定义或者标准库中提供的类型中。

## `Send` 允许在线程间转移所有权

`Send` 标记特质表明类型的所有权可以在线程间传递。

任何完全由 `Send` 的类型组成的类型会被自动标记为 `Send`，除了裸指针（ raw pointer ），几乎所有基本类型都是 `Send` 的。不过有一些例外，比如 `Rc<T>` 类型。

智能指针 `Rc<T>` 不是 `Send` 的，因为如果克隆了 `Rc<T>` 的值并尝试将克隆的所有权转移到另一个线程，两个线程都可能同时更新引用计数（ 这将引发错误 ），拥有线程安全的引用计数而付出性能代价。为此，`Rc<T>` 被实现为用于单线程场景。

Rust 类型系统和 `trait bound` 会禁止在线程间发送未标记为 `Send` 的类型。

当尝试在线程间发送 `Rc<T>` 的时候，会得到错误：

```shell
the trait Send is not implemented for Rc<Mutex<i32>>`。
```

而换用标记为 `Send` 的 `Arc<T>` 时，代码可通过编译。

## `Sync` 允许多线程访问

`Sync` 标记特质表明类型可以安全的在多个线程中拥有其值的引用。即对于任意类型 `T`，如果 `&T` 是 `Send` 的话 `T` 就是 `Sync` 的。这意味着其引用就可以安全的发送到另一个线程。

与 `Send` 类似，Rust 中的基本类型是 `Sync` 的，完全由 `Sync` 的类型组成的类型也是 `Sync` 的。

智能指针 `Rc<T>` 也不是 `Sync` 的，这与其不是 `Send` 的原因相同。

`RefCell<T>` 和 `Cell<T>` 类型不是 `Sync` 的。`RefCell<T>` 在运行时的借用检查不是线程安全的。

`Mutex<T>` 是 `Sync` 的，可被用于在多线程中共享访问。

## 手动实现 `Send` 和 `Sync` 是不安全的

通常不需要手动实现 `Send` 和 `Sync` 特质，因为由 `Send` 和 `Sync` 组成的类型，会自动被标记为是 `Send` 和 `Sync` 的。并且标记特质无需实现任何方法，它们只是用来加强并发相关的不可变性的。手动实现这些标记特质涉及**编写不安全的 Rust 代码**。

当前重点是，在创建由不是 `Send` 和 `Sync` 的部分构成的并发类型时，需要多加注意确保并发安全。
