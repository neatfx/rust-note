# 模块系统

编写大型程序时，在脑中跟踪整个程序开始变得不太可能，因此组织代码非常重要。通过将相关的功能分组以及拆分功能不同的代码，将能够理清实现特定功能的代码位置以及在何处可以改变某个功能。

当项目不断增长，可以通过将代码拆分到多个模块进而拆分到多个文件来组织代码。一个 Package 可包含多个二进制 Crates 以及一个可选的库 Crate。当 Package 不断变大，可将部分代码提取到单独的 Crates，使其成为外部依赖。本章节将介绍所有这些技术。Cargo 还针对由一系列相互关联的 Packages 共同演进构成的特大型项目提供了 “工作区”（ workspaces ）特性进行支持，详情可参考 [“Cargo Workspaces”](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html) 章节。

除了将功能分组，封装实现细节可在更高层面上重用代码：一旦实现了某个操作，其他代码便可通过其代码的公开接口进行调用而无需知晓其实现细节。编写代码定义哪部分是公开给其他代码使用的，哪部分是保留了修改权利的私有功能实现细节。这是另一种减少需要记忆的细节数量的方式。

一个相关的概念是 `作用域`：代码所在的嵌套上下文拥有一系列被定义为 “作用域内” 的名称。当读写编译代码时，程序员和编译器不仅需要知道某个特定位置的特定名称是否指向一个变量、函数、结构体、枚举、模块、常量或者其它项，而且需要知道其含义。可以创建作用域并改变哪些名字在作用域内哪些在作用域外。同一个作用域中不能存在两个同名的项目；Rust 中包含了可用的工具来解决命名冲突。

Rust 有很多用于管理代码组织的功能，包括暴露哪些细节，哪些细节是私有的，以及程序中每个作用域中有哪些名称。这些特性，有时被统称为 “模块系统”，包括：

- Packages：Cargo 功能，用于构建、测试、分享 `Crates`
- Crates：由模块构成的模块树，能够生成库或者可执行文件
- Modules & use：控制文件结构、作用域及路径的私密性
- Paths：结构体、函数或者模块等项目的命名方式

本章节内容包含上述功能特性，讨论它们如何相互作用，并讲解如何利用它们对作用域进行管理。到最后，你将对模块系统有很好的理解并像专家一样使用作用域。

## `Packages` 和 `Crates`

`crate` 即一个二进制文件或者库。

`crate root` 是最先被传给 Rust 编译器进行编译并构成 `crate` 的根模块的源文件（ 例如 `src/lib.rs`、`src/main.rs` ）

`package` 是提供一系列功能集合的一个或多个 `crates`，`package` 包含一个用于描述如何编译这些 `crates` 的 `Cargo.toml` 文件

### `Package` 的构成规则

- `package` 可以不包含库 `crate` 或者仅包含一个库 `crate`
- `package` 可以包含任意数量的二进制 `crates`
- `package` 必须包含至少一个 `crate`（ 库 `crate` 或者 二进制 `crate` ）

使用 `cargo new` 命令即创建包：

```shell
cargo new my-project
     Created binary (application) `my-project` package
ls my-project
Cargo.toml
src
ls my-project/src
main.rs
```

注意 `Cargo.toml` 中并没有提到 `src/main.rs` 文件，这是因为 Cargo 遵循约定：`src/main.rs` 是与包同名的二进制 `crate` 的 `crate root`。同样的，Cargo 知道如果包目录包含 `src/lib.rs`，那么该包包含一个与它同名的库 crate，并且`src/lib.rs` 是 `crate root`。`crate root` 被 Cargo 传给 `rustc` 用来构建库或者二进制。

示例代码中的包只包含了 `src/main.rs` ，表示它只包含一个名为 “my-project” 的二进制 `crate`。如果一个包同时包含 `src/main.rs` 和 `src/lib.rs`，那么它将有两个与包同名的 `crates`：一个二进制和一个库。可以通过将文件放置于 `src/bin` 目录（ 每个文件将成为一个单独的二进制 `crate` ）的方式使一个包同时拥有多个二进制 `crates`。

包含 3 个二进制 crates、1个库 crate 的 package 示例：

```shell
my-project
 ├── Cargo.toml # 配置文件
 └── src
     ├── bin
     │   ├── a.rs # 单独的二进制 crate
     │   └── b.rs # 单独的二进制 crate
     ├── lib.rs # 库 crate - “my-project” 的 “crate root”
     └── main.rs # 二进制 crate - “my-project” 的 “crate root”
```

crate 将相关的功能组合在一起放到一个作用域中，因此很容易在多个项目间共享功能。将 `crate` 引入项目作用域即可通过 `crate` 名来使用其所提供的功能。

将 `crate` 的功能限定在它自身的作用域中能够清楚界定某个功能是定义在我们自己编写的 crate 中还是定义于其它 crate 中，并阻止潜在的冲突。例如，`rand` crate 提供了一个名为 `Rng` 的特质。我们在自己编写的 crate 中定义一个名为 `Rng` 的结构体。因为 `crate` 的功能在它本身作用域中被命名，当我们添加 `rand` crate 作为依赖，编译器不会搞混 `Rng` 名称的指向。在我们编写的 `crate` 中，`Rng` 指向我们定义的 `struct Rng`，而 `rand` crate 中的 `Rng` 特质则以 `rand::Rng` 的形式访问。

## 定义 `Module` 用于控制作用域及私密性

Modules 用于将 `crate` 内的代码组织到不同的分组，增强其可读性并易于重用。Modules 还访问项目的私密性，即某个项目可以被外部代码使用（ public ）或者是一个不对外开放使用的内部实现细节（ private ）。

编写一个提供餐馆功能的库 crate 作为示例。当前只定义函数签名，函数体留空暂时不做具体代码实现。

在餐饮业，餐馆的一部分被称之为 “front of house 外场”，另一部分被称为 “back of house 工作区”。外场即顾客所在的地方：服务员安排顾客就坐、服务客人点单买单、酒保制作饮品。工作区则是主厨和厨师们在厨房工作、碗碟清洗以及经理们处理行政工作的地方。

使用 `cargo new --lib restaurant` 命令创建一个新库，并在 `src/lib.rs` 文件中定义以下模块和函数签名：

```rust
// 利用嵌套模块对函数进行组织
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
```

通过使用模块，能够将相关的定义分组到一起并标明它们为何相关。使用这些代码的程序员可以基于分组浏览代码而没有必要通读代码中的全部定义，因此能够很容易地找到他们想使用的定义。在为代码添加新功能时知道在哪里放置代码不会破坏程序原有的组织。

前面提到过 `src/main.rs` 和 `src/lib.rs` 被称为 “crate root”。原因在于它们之中任何一个的内容会构成一个位于 crate 模块结构（ module tree ）根部的名为 `crate` 的模块。

代码对应的模块树：

```shell
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

模块 `hosting` 嵌套在 `front_of_house` 中，模块 `serving` 和模块 `hosting` 是模块 `front_of_house` 的子模块，整个模块树位于隐式模块 `crate` 的 `root`。

模块树会让人联想到计算机中的文件系统目录，这是一个非常恰当的比较，使用模块组织代码正如文件系统目录包含文件一样。我们同样也需要一个方法来找到模块。

## 使用路径在模块树中查找项目

与使用路径浏览文件系统一样，路径也被用于在模块树中查找项目，路径有两种形式:

- 绝对路径。从 `crate root` 开始，使用 `crate` 名或者字面 `crate`
- 相对路径。从当前模块开始，以 `self`、`super` 或当前模块内的标识符作为开头

绝对路径和相对路径后跟随一个或多个由 `::` 分隔的标识符。

回到前面的示例代码，如何调用 “add_to_waitlist” 函数？该函数的路径是什么？将示例代码进行简化来演示两种从定义于 crate root 的新函数 “eat_at_restaurant” 中调用 “add_to_waitlist” 函数的方法。`“eat_at_restaurant”` 函数是库 crate 所提供的 API 的一部分。因此，使用 `pub` 关键字进行了标注。

```rust
// 模块 front_of_house 是定义于与 main 函数相同模块树级别的模块
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // add_to_waitlist 函数与 eat_at_restaurant 在同一个 crate 中定义，因此可使用 crate 关键字开始一个绝对路径
    // 使用 crate 作为开头表示从 crate root 开始查找，这与使用 “/” 从文件系统根目录开始查找类似
    crate::front_of_house::hosting::add_to_waitlist();

    // front_of_house 模块与 eat_at_restaurant 函数共同定义于模块树的同一级，以模块名称开头表示一个相对路径
    front_of_house::hosting::add_to_waitlist();
}
```

选择相对路径还是绝对路径取决于是否有可能单独移动某项定义代码还是与使用它的代码一起移动。例如：如果将 `front_of_house` 模块和 `eat_at_restaurant` 函数一同移动到名为 `customer_experience` 的新模块，需要更新指向 `add_to_waitlist` 的绝对路径，但相对路径仍然有效。如果将 `eat_at_restaurant` 函数单独移动到名为 `dining` 的新模块，指向 `add_to_waitlist` 函数的绝对路径保持有效，但是相对路径需要更新。我们倾向于指定绝对路径，因为更有可能对相互独立的代码定义及项目调用进行移动。

编译示例代码，会出现错误：

```shell
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --> src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^

error[E0603]: module `hosting` is private
  --> src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |
```

错误信息表明模块 `hosting` 是私有的。换言之，到 `hosting` 模块及 `add_to_waitlist` 函数的路径没有问题，但是无法访问私有区域，所以 Rust 不允许使用它们。

模块不仅用于组织代码，还用于定义 Rust 的私有边界：界线内对实现细节进行封装，不允许外部代码探究、调用或者依赖。如果想要使函数或者结构体私有，将其放入模块即可。

私有性在 Rust 中的工作方式：

- 所有的项（ 函数、方法、结构体、枚举、模块、常量 ）默认都是私有的
- 父模块中的项无法使用子模块中的私有项，但是子模块中的项可以使用先辈模块中的项。原因在于子模块包装并隐藏了它们的实现细节，但是子模块能够看到其自身定义所在的上下文。以餐馆的例子进行类比，将私有规则想象成是餐馆工作区：餐馆工作区里发生的事情对于餐馆顾客来说是不可见的，但是办公室经理能够看到其运营的餐馆并在其中做任何事情。

Rust 选择使用默认隐藏内部实现细节的模块系统，这样很清楚哪部分内部代码可以修改并且不会破坏外部代码。不过，可以使用 `pub` 关键字来使某个项公开，暴露子模块的内在部分给外部的先辈模块。

### 使用 `pub` 关键字公开路径

修改示例代码，先使私有模块 `hosting` 变为公开模块：

```rust
// 模块 front_of_house 是定义于与 main 函数相同模块树级别的模块
mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    crate::front_of_house::hosting::add_to_waitlist();

    front_of_house::hosting::add_to_waitlist();
}
```

编译仍然无法通过：

```shell
$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --> src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --> src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |
```

为 `hosting` 模块添加 `pub` 关键字只是将模块变为公有，但是 `hosting` 模块的内容依旧是私有的。使模块公有并不能公有化其内容。使前代的代码可以指向它。用在模块上的 `pub` 关键字仅使来自先辈的代码可以指向它。

因此还需要在私有的 `add_to_waitlist` 函数前增加 `pub` 关键字使其变为公有函数：

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    crate::front_of_house::hosting::add_to_waitlist();

    front_of_house::hosting::add_to_waitlist();
}
```

注意：模块 `sound` 是定义于与 `main` 函数相同模块树级别的模块（ 两者共同定义于 `crate` 模块的 `root` ），可以从 `main` 中访问 `sound` 模块，尽管 `sound` 模块不是公有的。

### 使用 `super` 开始相对路径

```rust
mod instrument {
    fn clarinet() {
        super::breathe_in();
    }
}

fn breathe_in() {
    // 函数体
}
```

模块增加嵌套后，使用 `super` 开始的相对路径函数调用不受影响：

```rust
mod sound {
    mod instrument {
        fn clarinet() {
            super::breathe_in();
        }
    }

    fn breathe_in() {
        // 函数体
    }
}
```

### 使用 `pub` 定义结构体

在结构体定义中使用 `pub`，可以使结构体公有，不过结构体的字段仍是私有的。

```rust
mod plant {
    // 公有结构体
    pub struct Vegetable {
        pub name: String, // 公有字段
        id: i32, // 私有字段
    }

    impl Vegetable {
        // 公有关联函数
        // 因为私有字段的原因，只有通过该公有关联函数才可以创建 Vegetable 示例
        pub fn new(name: &str) -> Vegetable {
            Vegetable {
                name: String::from(name),
                id: 1,
            }
        }
    }
}

fn main() {
    let mut v = plant::Vegetable::new("squash");

    v.name = String::from("butternut squash");
    println!("{} are delicious", v.name);

    // 如果将如下行取消注释代码将无法编译:
    // println!("The ID is {}", v.id);
}
```

### 使用 `pub` 定义枚举

在枚举定义中使用 `pub`，其所有枚举成员都将成为公有。

```rust
mod menu {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

fn main() {
    let order1 = menu::Appetizer::Soup;
    let order2 = menu::Appetizer::Salad;
}
```

## 将名称引入作用域

### 使用 `use` 关键字将模块引入作用域

注意：通过 `use` 引入作用域的路径也会检查私有性。

#### 绝对路径

```rust
mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // 函数体
        }
    }
}

use crate::sound::instrument; // 绝对路径

fn main() {
    instrument::clarinet();
    instrument::clarinet();
    instrument::clarinet();
}
```

移动调用项的代码时绝对路径无需移动:

```rust
mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // 函数体
        }
    }
}

mod performance_group {
    use crate::sound::instrument;

    pub fn clarinet_trio() {
        instrument::clarinet();
        instrument::clarinet();
        instrument::clarinet();
    }
}

fn main() {
    performance_group::clarinet_trio();
}
```

#### 相对路径

**指定 `use` 后以 `self` 开头的相对路径在未来可能不是必须的。**

```rust
mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // 函数体
        }
    }
}

use self::sound::instrument; // 相对路径

fn main() {
    instrument::clarinet();
    instrument::clarinet();
    instrument::clarinet();
}
```

选择采用相对或绝对路径能否减少代码修改取决于模块树如何变化，因为定义和调用项的代码更有可能相互独立的在模块树中移动，所以选择绝对路径可能更加适用。

### 推荐使用习惯

#### 通过 `use` 指定函数的父模块接着指定父模块来调用方法

不好的写法：

```rust
mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // 函数体
        }
    }
}

use crate::sound::instrument::clarinet;

fn main() {
    clarinet();
    clarinet();
    clarinet();
}
```

推荐写法：

```rust
mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // 函数体
        }
    }
}

mod performance_group {
    use crate::sound::instrument;

    pub fn clarinet_trio() {
        instrument::clarinet();
        instrument::clarinet();
        instrument::clarinet();
    }
}
```

#### 通过 `use` 指定结构体、枚举和其它项的全路径

不好的写法：

```rust
use std::collections;

fn main() {
    let mut map = collections::HashMap::new();
    map.insert(1, 2);
}
```

推荐写法：

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```

#### 将两个同名类型引入作用域时使用父模块

```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
#     Ok(())
}
fn function2() -> io::Result<()> {
#     Ok(())
}
```

如果指定 `use std::fmt::Result` 和 `use std::io::Result`，则作用域中会有两个 `Result` 类型，Rust 将无法确定使用哪一个。

### 重命名引入作用域的类型

将两个同名类型引入同一作用域还有一个解决办法：通过在 `use` 后加上 `as` 和一个新名称来为此类型指定一个新的本地名称。

```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
#     Ok(())
}
fn function2() -> IoResult<()> {
#     Ok(())
}
```

### 重新导出名称

```rust
mod sound {
    pub mod instrument {
        pub fn clarinet() {
            // 函数体
        }
    }
}

mod performance_group {
    // 导入 sound::instrument 后作为 performance_group::instrument 导出
    pub use crate::sound::instrument;

    pub fn clarinet_trio() {
        instrument::clarinet();
        instrument::clarinet();
        instrument::clarinet();
    }
}

fn main() {
    // 通过模块自有方法间接调用 sound::instrument::clarinet
    performance_group::clarinet_trio();

    // 使用重新导出的路径 sound::instrument::clarinet 调用
    performance_group::instrument::clarinet();
}
```

## 使用外部包

首先在 `Cargo.toml` 中加入依赖项，Cargo 将从 [crates.io](https://crates.io) 下载 `rand` 及其依赖并使其可用：

```shell
[dependencies]
rand = "0.5.5"
```

然后引入依赖并使用：

```rust
use rand::Rng; // 将 Rng 特质引入作用域

fn main() {
    let secret_number = rand::thread_rng().gen_range(1, 101);
}
```

## 使用 Rust 标准库

相对于用户 `package` 来说 Rust 标准库也是外部包。只是其跟随 Rust 语言一同分发，因此无需通过配置 `Cargo.toml` 引入，但是仍需要通过 `use` 将标准库中的项引入项目包的作用域：

```rust
use std::collections::HashMap;
```

## 通过嵌套路径精简 `use` 语句

```rust
use std::cmp::Ordering;
use std::io;
```

可以改进为：

```rust
use std::{cmp::Ordering, io};
```

```rust
// 将 std::io 和 std::io::Write 同时引入作用域
use std::io;
use std::io::Write;
```

可以改进为：

```rust
use std::io::{self, Write};
```

## 将所有的公有定义引入作用域

通过在路径后指定 `*`（ glob 运算符 ），可以将一个路径下的所有公有项引入作用域：

```rust
// 将 std::collections 中定义的所有公有项引入当前作用域
use std::collections::*;
```

这种方式的缺点在于难以推导作用域中有什么名称以及它们是在何处定义的。

`glob` 运算符常用于测试模块 `tests` 中，将所有内容引入作用域；有时也用于 `prelude` 模式。

## 将模块分割进不同文件

随着代码增长可以将模块移动到独立的文件中，当模块变得更复杂时，可将其定义拆分移动到单独的文件中，使代码更容易阅读。

```rust
// src/main.rs

// 声明 sound 模块，其内容位于 src/sound.rs 文件
// 使用分号而不是代码块告诉 Rust 在另一个与模块同名的文件中加载模块的内容
mod sound;

fn main() {
    // 绝对路径
    crate::sound::instrument::clarinet();

    // 相对路径
    sound::instrument::clarinet();
}
```

```rust
// src/sound.rs

// 声明 instrument 模块，其内容位于 src/sound/instrument.rs 文件
// 使用分号而不是代码块告诉 Rust 在另一个与模块同名的文件中加载模块的内容
pub mod instrument;
```

```rust
// src/sound/instrument.rs

pub fn clarinet() {
    // 函数体
}
```
